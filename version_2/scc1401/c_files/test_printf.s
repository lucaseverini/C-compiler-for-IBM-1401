     ****************************************************************
     ***  test_printf.s
     ***  Generated by Small-C Compiler on 15-Apr-2015 5:47:39 PM
     ****************************************************************
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * Index Register 1
               ORG  92
     X2        DSA  0                  * Index Register 2 (stack pointer)
               ORG  97
     X3        DSA  0                  * Index Register 3 (stack frame pointer)
     
     ****************************************************************
     
     * GLOBAL/STATIC DATA AND VARIABLES
     * seed size:5 offset:600
     * CONST_STR_LITERAL_1 size:17 offset:605
     * __putchar_pos size:3 offset:622
     * __putchar_last size:3 offset:625
     * __getCharPosition size:3 offset:628
     * c1 size:3 offset:631
     * CONST_STR_LITERAL_8 size:17 offset:634
     * CONST_STR_LITERAL_9 size:8 offset:651
     * CONST_STR_LITERAL_10 size:9 offset:659
     * CONST_STR_LITERAL_11 size:7 offset:668
     * CONST_STR_LITERAL_12 size:8 offset:675
     * CONST_STR_LITERAL_13 size:7 offset:683
     * CONST_STR_LITERAL_14 size:8 offset:690

               ORG  600                * seed
               DCW  @69105@

               ORG  605                * CONST_STR_LITERAL_1
               DCW  @0@
               DCW  @1@
               DCW  @2@
               DCW  @3@
               DCW  @4@
               DCW  @5@
               DCW  @6@
               DCW  @7@
               DCW  @8@
               DCW  @9@
               DCW  @A@
               DCW  @B@
               DCW  @C@
               DCW  @D@
               DCW  @E@
               DCW  @F@
               DCW  @'@

               ORG  622                * __putchar_pos
               DCW  @201@

               ORG  625                * __putchar_last
               DCW  @200@

               ORG  628                * __getCharPosition
               DCW  @081@

               ORG  631                * c1
               DCW  @634@

               ORG  634                * CONST_STR_LITERAL_8
               DCW  @0@
               DCW  @1@
               DCW  @2@
               DCW  @3@
               DCW  @4@
               DCW  @5@
               DCW  @6@
               DCW  @7@
               DCW  @8@
               DCW  @9@
               DCW  @A@
               DCW  @B@
               DCW  @C@
               DCW  @D@
               DCW  @E@
               DCW  @F@
               DCW  @'@

               ORG  651                * CONST_STR_LITERAL_9
               DCW  @C@
               DCW  @1@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  659                * CONST_STR_LITERAL_10
               DCW  @*@
               DCW  @C@
               DCW  @1@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @C@
               DCW  @;@
               DCW  @'@

               ORG  668                * CONST_STR_LITERAL_11
               DCW  @C@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  675                * CONST_STR_LITERAL_12
               DCW  @*@
               DCW  @C@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @C@
               DCW  @;@
               DCW  @'@

               ORG  683                * CONST_STR_LITERAL_13
               DCW  @X@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

               ORG  690                * CONST_STR_LITERAL_14
               DCW  @&@
               DCW  @X@
               DCW  @:@
               DCW  @ @
               DCW  @%@
               DCW  @D@
               DCW  @;@
               DCW  @'@

     * START POSITION OF PROGRAM CODE
               ORG  698
     START     NOP                     * Program starts here

     * SET X2 TO BE THE STACK POINTER (STACK GROWS UPWARD)
               SBR  X2,399             * Set X2 to stack pointer value
               MCW  X2,X3              * Copy stack pointer in X3

               B    LLEAAA             * Jump to function main
               H                       * Program executed. System halts

     ********************************************************************************
     * Function : main
     ********************************************************************************
     LLEAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LMEAAA]
     * c size:3 offset:3
     * x size:5 offset:6

     * Push (11)
               MA   LMFAAA,X2          * Add 11 to stack pointer
     * Assignment (c = (c1 + 10))
     * Addition (c1 + 10)
     * Static Variable (c1 : 633)
     * Push (633:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  633,0+X2           * Load memory 633 in stack
     * Constant (10 : LNFAAA)
     * Push (LNFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LNFAAA,0+X2        * Load data 010 in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (LYEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYEAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (c = (c1 + 10))

     * Assignment (x = (*((*int) c)))
     * DereferenceExpression (*((*int) c))
     * Local Variable (c : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*((*int) c))

     * Push (LMFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LMFAAA,0+X2        * Load data 011 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (x = (*((*int) c)))

     * Assignment (x = test(c, 1))
     * Function Call test(c, 1)
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Constant (1 : LWEAAA)
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
     * Local Variable (c : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LSDAAA             * Jump to function test

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call test(c, 1)

     * Push (LMFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LMFAAA,0+X2        * Load data 011 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (x = test(c, 1))

     * Function Call printf(CONST_STR_LITERAL_9, ((int) c1))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Static Variable (c1 : 633)
     * Push (633:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  633,0+X2           * Load memory 633 in stack
     * Cast Pointer(c1) to Number
               B    PTRNMN             * Jump to snippet pointer_to_number

     * Static Array (CONST_STR_LITERAL_9:char [8])
     * Push (LOFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LOFAAA,0+X2        * Load data 651 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LPCAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_9, ((int) c1))

     * Function Call printf(CONST_STR_LITERAL_10, (*c1))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*c1)
     * Static Variable (c1 : 633)
     * Push (633:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  633,0+X2           * Load memory 633 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*c1)

     * Static Array (CONST_STR_LITERAL_10:char [9])
     * Push (LPFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LPFAAA,0+X2        * Load data 659 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LPCAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_10, (*c1))

     * Function Call printf(CONST_STR_LITERAL_11, ((int) c))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Local Variable (c : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Cast Pointer(c) to Number
               B    PTRNMN             * Jump to snippet pointer_to_number

     * Static Array (CONST_STR_LITERAL_11:char [7])
     * Push (LQFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LQFAAA,0+X2        * Load data 668 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LPCAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_11, ((int) c))

     * Function Call printf(CONST_STR_LITERAL_12, (*c))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*c)
     * Local Variable (c : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*c)

     * Static Array (CONST_STR_LITERAL_12:char [8])
     * Push (LRFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LRFAAA,0+X2        * Load data 675 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LPCAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_12, (*c))

     * Function Call printf(CONST_STR_LITERAL_13, x)
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Local Variable (x : 11+X3)
     * Push (11+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  11+X3,0+X2         * Load memory 11+X3 in stack
     * Static Array (CONST_STR_LITERAL_13:char [7])
     * Push (LSFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LSFAAA,0+X2        * Load data 683 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LPCAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_13, x)

     * Function Call printf(CONST_STR_LITERAL_14, ((int) ( &x )))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * AddressOf ( &x )
     * Push (LMFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LMFAAA,0+X2        * Load data 011 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Cast Pointer(( &x )) to Number
               B    PTRNMN             * Jump to snippet pointer_to_number

     * Static Array (CONST_STR_LITERAL_14:char [8])
     * Push (LTFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LTFAAA,0+X2        * Load data 690 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LPCAAA             * Jump to function printf

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call printf(CONST_STR_LITERAL_14, ((int) ( &x )))

     LMEAAA    NOP                     * Last block instruction
     * Pop (11)
               MA   LUFAAA,X2          * Add -11 to stack pointer
     * End [Block ending at LMEAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : main
     ********************************************************************************

     ********************************************************************************
     * Function : genRand
     ********************************************************************************
     LBAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LCAAAA]

     * Push (3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
     * Assignment (seed = (((42 * seed) + 19) % 100000))
     * Modulo (%) (((42 * seed) + 19) % 100000)
     * Constant (100000 : LOEAAA)
     * Push (LOEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LOEAAA,0+X2        * Load data 100000 in stack
     * Addition ((42 * seed) + 19)
     * Multiply (42 * seed)
     * Constant (42 : LQEAAA)
     * Push (LQEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LQEAAA,0+X2        * Load data 00042 in stack
     * Static Variable (seed : 604)
     * Push (604:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  604,0+X2           * Load memory 604 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Constant (19 : LSEAAA)
     * Push (LSEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LSEAAA,0+X2        * Load data 00019 in stack
               A    0+X2,15995+X2      * Add stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               B    SNPDIV             * Jump to snippet SNIP_DIV

     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LTEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LTEAAA,0+X2        * Load data 604 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (seed = (((42 * seed) + 19) % 100000))

     * Put on stack return value (seed)
     * Static Variable (seed : 604)
     * Push (604:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  604,0+X2           * Load memory 604 in stack
     * Pop (15997+X3:5)
               LCA  0+X2,15997+X3      * Load stack in 15997+X3
               MA   LREAAA,X2          * Add -5 to stack pointer

     LCAAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LCAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : genRand
     ********************************************************************************

     ********************************************************************************
     * Function : itoa
     ********************************************************************************
     LYAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LZAAAA]
     * start size:3 offset:3
     * digits size:3 offset:6
     * exp size:5 offset:9

               LCA  LVEAAA,9+X3        * Load *char 605 into memory 9+X3
               LCA  LWEAAA,14+X3       * Load int 1 into memory 14+X3
     * Push (14)
               MA   LXEAAA,X2          * Add 14 to stack pointer
     * Assignment (start = str)
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
     * Push (LYEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYEAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (start = str)

     * If [if ((value < 0) then [Block ending at LABAAA] else [if ((value == 0) then [Block ending at LBBAAA]]]
     * Less (value < 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (0 : LZEAAA)
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               MCW  LZEAAA,0+X2        * Move 0 in stack
               BL   LAFAAA             * Jump if less
               B    LBFAAA             * Jump to End
     LAFAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LBFAAA    NOP                     * End of Less
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LDBAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LABAAA]

     * Assignment ((*(str++)) = '-')
     * Constant ('-' : LCFAAA)
     * Push (LCFAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LCFAAA,0+X2        * Load data - in stack
     * PostIncrement (str++)
     * Push (LEFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LEFAAA,0+X2        * Load data I9B in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(str++)) = '-')

     * Assignment (value = (-value))
     * Negate (-value)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               ZS   0+X2
               B    CLNNMN             * Jump to snippet clean_number

     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (value = (-value))

     LABAAA    NOP                     * Last block instruction
     * End [Block ending at LABAAA]
     ***************************************

               B    LEBAAA             * Jump when true
     LDBAAA    NOP                     * Executed when False
     * If [if ((value == 0) then [Block ending at LBBAAA]]
     * Equal (value == 0)
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (0 : LZEAAA)
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LGFAAA             * Jump if equal
               B    LHFAAA             * Jump to End
     LGFAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LHFAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LCBAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LBBAAA]

     * Assignment ((str[0]) = '0')
     * Constant ('0' : LIFAAA)
     * Push (LIFAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LIFAAA,0+X2        * Load data 0 in stack
     * SubScript (str[0])
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
     * End SubScript (str[0])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment ((str[0]) = '0')

     * Assignment ((str[1]) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
     * SubScript (str[1])
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
               A    LWEAAA,0+X2        * Add offset 1 to point element 1
     * End SubScript (str[1])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment ((str[1]) = '\0')

     * Return to LZAAAA with return value start
     * Put on stack return value (start)
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load stack in 15984+X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
               B    LZAAAA             * Jump to end of function block

     LBBAAA    NOP                     * Last block instruction
     * End [Block ending at LBBAAA]
     ***************************************

     LCBAAA    NOP                     * Executed when False
     * End If [if ((value == 0) then [Block ending at LBBAAA]]

     LEBAAA    NOP                     * Executed when True
     * End If [if ((value < 0) then [Block ending at LABAAA] else [if ((value == 0) then [Block ending at LBBAAA]]]

     * While [while ((exp <= (value / base))) [Block ending at LFBAAA] top:LGBAAA bottom:LHBAAA]
     LGBAAA    NOP                     * Top of While
     * LessOrEqual (exp <= (value / base))
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Divide (value / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15989+X3,0+X2      * Load memory 15989+X3 in stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

               MCW  0+X2,15995+X2      * Move stack in stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               MCW  LWEAAA,0+X2        * Move 1 in stack
               BH   LJFAAA             * Jump if less or equal
               B    LKFAAA             * Jump to End
     LJFAAA    MCW  LZEAAA,0+X2        * Move 0 in stack
     LKFAAA    NOP                     * End of LessOrEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LHBAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LFBAAA]

     * Assignment (exp = (exp * base))
     * Multiply (exp * base)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15989+X3,0+X2      * Load memory 15989+X3 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LXEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LXEAAA,0+X2        * Load data 014 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (exp = (exp * base))

     LFBAAA    NOP                     * Last block instruction
     * End [Block ending at LFBAAA]
     ***************************************

               B    LGBAAA             * Jump to top of While

     LHBAAA    NOP                     * Bottom of While
     * End While [while ((exp <= (value / base))) [Block ending at LFBAAA] top:LGBAAA bottom:LHBAAA]

     * While [while (exp) [Block ending at LIBAAA] top:LJBAAA bottom:LKBAAA]
     LJBAAA    NOP                     * Top of While
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LKBAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LIBAAA]

     * Assignment ((*(str++)) = (digits[(value / exp)]))
     * SubScript (digits[(value / exp)])
     * Local Variable (digits : 9+X3)
     * Push (9+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  9+X3,0+X2          * Load memory 9+X3 in stack
     * Divide (value / exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

               MCW  0+X2,15995+X2      * Move stack in stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Put raw index on the stack
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 in stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Stack top is now array index
               B    NMNPTR             * Jump to snippet number_to_pointer

               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Stack top is location in array now
     * End SubScript (digits[(value / exp)])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * PostIncrement (str++)
     * Push (LEFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LEFAAA,0+X2        * Load data I9B in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(str++)) = (digits[(value / exp)]))

     * Assignment (value = (value % exp))
     * Modulo (%) (value % exp)
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
     * Parameter Variable (value : 15997+X3)
     * Push (15997+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (value = (value % exp))

     * Assignment (exp = (exp / base))
     * Divide (exp / base)
     * Parameter Variable (base : 15989+X3)
     * Push (15989+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15989+X3,0+X2      * Load memory 15989+X3 in stack
     * Local Variable (exp : 14+X3)
     * Push (14+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  14+X3,0+X2         * Load memory 14+X3 in stack
               B    SNPDIV             * Jump to snippet SNIP_DIV

               MCW  0+X2,15995+X2      * Move stack in stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LXEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LXEAAA,0+X2        * Load data 014 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (exp = (exp / base))

     LIBAAA    NOP                     * Last block instruction
     * End [Block ending at LIBAAA]
     ***************************************

               B    LJBAAA             * Jump to top of While

     LKBAAA    NOP                     * Bottom of While
     * End While [while (exp) [Block ending at LIBAAA] top:LJBAAA bottom:LKBAAA]

     * Assignment ((*str) = '\0')
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
     * Parameter Variable (str : 15992+X3)
     * Push (15992+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  15992+X3,0+X2      * Load memory 15992+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*str) = '\0')

     * Put on stack return value (start)
     * Local Variable (start : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (15984+X3:3)
               LCA  0+X2,15984+X3      * Load stack in 15984+X3
               MA   LUEAAA,X2          * Add -3 to stack pointer

     LZAAAA    NOP                     * Last block instruction
     * Pop (14)
               MA   LLFAAA,X2          * Add -14 to stack pointer
     * End [Block ending at LZAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : itoa
     ********************************************************************************

     ********************************************************************************
     * Function : printf
     ********************************************************************************
     LPCAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LQCAAA]
     * arg size:3 offset:3
     * c size:1 offset:6
     * addrP size:3 offset:7
     * addrC size:1 offset:10

     * Push (11)
               MA   LMFAAA,X2          * Add 11 to stack pointer
     * Assignment (arg = ((*char) (( &cformat_str ) + 15997)))
     * Addition (( &cformat_str ) + 15997)
     * AddressOf ( &cformat_str )
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Constant (15997 : LUEAAA)
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (LYEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYEAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = ((*char) (( &cformat_str ) + 15997)))

     * While [while (((c = (*(cformat_str++))) != '\0')) [Block ending at LRCAAA] top:LMDAAA bottom:LNDAAA]
     LMDAAA    NOP                     * Top of While
     * NotEqual (!=) ((c = (*(cformat_str++))) != '\0')
     * Assignment (c = (*(cformat_str++)))
     * DereferenceExpression (*(cformat_str++))
     * PostIncrement (cformat_str++)
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(cformat_str++))

     * Push (LXFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LXFAAA,0+X2        * Load data 007 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
               LCA  0+X2,0+X1          * Load stack in memory X1
     * End Assignment (c = (*(cformat_str++)))

     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               BE   LVFAAA             * Jump if equal
               B    LWFAAA             * Jump to End
     LVFAAA    MCW  LZEAAA,0+X2        * Move 0 in stack
     LWFAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LNDAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LRCAAA]

     * If [if ((c != '%') then [Block ending at LSCAAA] else [Block ending at LTCAAA]]
     * NotEqual (!=) (c != '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('%' : LAGAAA)
     * Push (LAGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LAGAAA,0+X2        * Load data % in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               BE   LYFAAA             * Jump if equal
               B    LZFAAA             * Jump to End
     LYFAAA    MCW  LZEAAA,0+X2        * Move 0 in stack
     LZFAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LKDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LSCAAA]

     * Function Call putchar(c)
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LLBAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar(c)

     LSCAAA    NOP                     * Last block instruction
     * End [Block ending at LSCAAA]
     ***************************************

               B    LLDAAA             * Jump when true
     LKDAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LTCAAA]

     * Assignment (c = (*(cformat_str++)))
     * DereferenceExpression (*(cformat_str++))
     * PostIncrement (cformat_str++)
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(cformat_str++))

     * Push (LXFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LXFAAA,0+X2        * Load data 007 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment (c = (*(cformat_str++)))

     * If [if ((c == '%') then [Block ending at LUCAAA] else [if ((c == 'C') then [Block ending at LVCAAA] else [if ((c == 'S') then [Block ending at LWCAAA] else [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]]]]
     * Equal (c == '%')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('%' : LAGAAA)
     * Push (LAGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LAGAAA,0+X2        * Load data % in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LBGAAA             * Jump if equal
               B    LCGAAA             * Jump to End
     LBGAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LCGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LIDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LUCAAA]

     * Function Call putchar('%')
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Constant ('%' : LAGAAA)
     * Push (LAGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LAGAAA,0+X2        * Load data % in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LLBAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar('%')

     LUCAAA    NOP                     * Last block instruction
     * End [Block ending at LUCAAA]
     ***************************************

               B    LJDAAA             * Jump when true
     LIDAAA    NOP                     * Executed when False
     * If [if ((c == 'C') then [Block ending at LVCAAA] else [if ((c == 'S') then [Block ending at LWCAAA] else [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]]]
     * Equal (c == 'C')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('C' : LFGAAA)
     * Push (LFGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LFGAAA,0+X2        * Load data C in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LDGAAA             * Jump if equal
               B    LEGAAA             * Jump to End
     LDGAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LEGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LGDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LVCAAA]

     * Function Call putchar((*arg))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*arg)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*arg)

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LLBAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar((*arg))

     * Assignment (arg = (arg + 15999))
     * Addition (arg + 15999)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15999 : LFFAAA)
     * Push (LFFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LFFAAA,0+X2        * Load data I9I in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (LYEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYEAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15999))

     LVCAAA    NOP                     * Last block instruction
     * End [Block ending at LVCAAA]
     ***************************************

               B    LHDAAA             * Jump when true
     LGDAAA    NOP                     * Executed when False
     * If [if ((c == 'S') then [Block ending at LWCAAA] else [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]]
     * Equal (c == 'S')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('S' : LIGAAA)
     * Push (LIGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LIGAAA,0+X2        * Load data S in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LGGAAA             * Jump if equal
               B    LHGAAA             * Jump to End
     LGGAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LHGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LEDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LWCAAA]

     * Function Call puts((*((**char) arg)))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*((**char) arg))
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*((**char) arg))

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LWBAAA             * Jump to function puts

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call puts((*((**char) arg)))

     * Assignment (arg = (arg + 15997))
     * Addition (arg + 15997)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15997 : LUEAAA)
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (LYEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYEAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15997))

     LWCAAA    NOP                     * Last block instruction
     * End [Block ending at LWCAAA]
     ***************************************

               B    LFDAAA             * Jump when true
     LEDAAA    NOP                     * Executed when False
     * If [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]
     * Equal (c == 'D')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('D' : LLGAAA)
     * Push (LLGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LLGAAA,0+X2        * Load data D in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LJGAAA             * Jump if equal
               B    LKGAAA             * Jump to End
     LJGAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LKGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LCDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LXCAAA]
     * a size:7 offset:11

     * Push (7)
               MA   LXFAAA,X2          * Add 7 to stack pointer
     * Function Call itoa((*((*int) arg)), a, 10)
     * Push (3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
     * Constant (10 : LMGAAA)
     * Push (LMGAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LMGAAA,0+X2        * Load data 00010 in stack
     * Local Array (a:char [7])
     * Push (LNGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LNGAAA,0+X2        * Load data 012 in stack
               MA   X3,0+X2            * Add X3 to stack
     * DereferenceExpression (*((*int) arg))
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*((*int) arg))

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LYAAAA             * Jump to function itoa

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Function Call itoa((*((*int) arg)), a, 10)

     * Function Call puts(a)
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Local Array (a:char [7])
     * Push (LNGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LNGAAA,0+X2        * Load data 012 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LWBAAA             * Jump to function puts

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call puts(a)

     * Assignment (arg = (arg + 15995))
     * Addition (arg + 15995)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15995 : LREAAA)
     * Push (LREAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LREAAA,0+X2        * Load data I9E in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (LYEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYEAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15995))

     LXCAAA    NOP                     * Last block instruction
     * Pop (7)
               MA   LOGAAA,X2          * Add -7 to stack pointer
     * End [Block ending at LXCAAA]
     ***************************************

               B    LDDAAA             * Jump when true
     LCDAAA    NOP                     * Executed when False
     * If [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]
     * Equal (c == 'P')
     * Local Variable (c : 7+X3)
     * Push (7+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  7+X3,0+X2          * Load memory 7+X3 in stack
     * Constant ('P' : LRGAAA)
     * Push (LRGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LRGAAA,0+X2        * Load data P in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LPGAAA             * Jump if equal
               B    LQGAAA             * Jump to End
     LPGAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LQGAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LADAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LYCAAA]

     * Assignment (addrP = arg)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Push (LNFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LNFAAA,0+X2        * Load data 010 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (addrP = arg)

     * Assignment (addrC = (*addrP))
     * DereferenceExpression (*addrP)
     * Local Variable (addrP : 10+X3)
     * Push (10+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  10+X3,0+X2         * Load memory 10+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*addrP)

     * Push (LMFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LMFAAA,0+X2        * Load data 011 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment (addrC = (*addrP))

     * Function Call putchar(addrC)
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * Local Variable (addrC : 11+X3)
     * Push (11+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  11+X3,0+X2         * Load memory 11+X3 in stack
     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LLBAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar(addrC)

     * Start asm block
               W    
     * End asm block
     * Start asm block
               W    
     * End asm block
     * Start asm block
               W    
     * End asm block
     * Assignment (arg = (arg + 15999))
     * Addition (arg + 15999)
     * Local Variable (arg : 6+X3)
     * Push (6+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  6+X3,0+X2          * Load memory 6+X3 in stack
     * Constant (15999 : LFFAAA)
     * Push (LFFAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LFFAAA,0+X2        * Load data I9I in stack
               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (LYEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYEAAA,0+X2        * Load data 006 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (arg = (arg + 15999))

     LYCAAA    NOP                     * Last block instruction
     * End [Block ending at LYCAAA]
     ***************************************

               B    LBDAAA             * Jump when true
     LADAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LZCAAA]

     * Return to LTCAAA with no return value
               B    LTCAAA             * Jump to end of function block

     LZCAAA    NOP                     * Last block instruction
     * End [Block ending at LZCAAA]
     ***************************************

     LBDAAA    NOP                     * Executed when True
     * End If [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]

     LDDAAA    NOP                     * Executed when True
     * End If [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]

     LFDAAA    NOP                     * Executed when True
     * End If [if ((c == 'S') then [Block ending at LWCAAA] else [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]]

     LHDAAA    NOP                     * Executed when True
     * End If [if ((c == 'C') then [Block ending at LVCAAA] else [if ((c == 'S') then [Block ending at LWCAAA] else [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]]]

     LJDAAA    NOP                     * Executed when True
     * End If [if ((c == '%') then [Block ending at LUCAAA] else [if ((c == 'C') then [Block ending at LVCAAA] else [if ((c == 'S') then [Block ending at LWCAAA] else [if ((c == 'D') then [Block ending at LXCAAA] else [if ((c == 'P') then [Block ending at LYCAAA] else [Block ending at LZCAAA]]]]]]

     LTCAAA    NOP                     * Last block instruction
     * End [Block ending at LTCAAA]
     ***************************************

     LLDAAA    NOP                     * Executed when True
     * End If [if ((c != '%') then [Block ending at LSCAAA] else [Block ending at LTCAAA]]

     LRCAAA    NOP                     * Last block instruction
     * End [Block ending at LRCAAA]
     ***************************************

               B    LMDAAA             * Jump to top of While

     LNDAAA    NOP                     * Bottom of While
     * End While [while (((c = (*(cformat_str++))) != '\0')) [Block ending at LRCAAA] top:LMDAAA bottom:LNDAAA]

     LQCAAA    NOP                     * Last block instruction
     * Pop (11)
               MA   LUFAAA,X2          * Add -11 to stack pointer
     * End [Block ending at LQCAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : printf
     ********************************************************************************

     ********************************************************************************
     * Function : putchar
     ********************************************************************************
     LLBAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LMBAAA]

     * Push (3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
     * If [if ((c != '\n') then [Block ending at LNBAAA] else [Block ending at LOBAAA]]
     * NotEqual (!=) (c != '\n')
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * Constant ('\n' : EOL)
     * Push (EOL:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  EOL,0+X2           * Load memory EOL in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               BE   LSGAAA             * Jump if equal
               B    LTGAAA             * Jump to End
     LSGAAA    MCW  LZEAAA,0+X2        * Move 0 in stack
     LTGAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LSBAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LNBAAA]

     * Assignment ((*(__putchar_pos++)) = c)
     * Parameter Variable (c : 15997+X3)
     * Push (15997+X3:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * PostIncrement (__putchar_pos++)
     * Push (LUGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUGAAA,0+X2        * Load data 624 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(__putchar_pos++)) = c)

     LNBAAA    NOP                     * Last block instruction
     * End [Block ending at LNBAAA]
     ***************************************

               B    LTBAAA             * Jump when true
     LSBAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LOBAAA]

     * While [while ((((int) __putchar_last) >= ((int) __putchar_pos))) [Block ending at LPBAAA] top:LQBAAA bottom:LRBAAA]
     LQBAAA    NOP                     * Top of While
     * GreaterOrEqual (((int) __putchar_last) >= ((int) __putchar_pos))
     * Static Variable (__putchar_last : 627)
     * Push (627:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  627,0+X2           * Load memory 627 in stack
     * Cast Pointer(__putchar_last) to Number
               B    PTRNMN             * Jump to snippet pointer_to_number

               B    CLNNMN             * Jump to snippet clean_number

     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  624,0+X2           * Load memory 624 in stack
     * Cast Pointer(__putchar_pos) to Number
               B    PTRNMN             * Jump to snippet pointer_to_number

               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               MCW  LWEAAA,0+X2        * Move 1 in stack
               BL   LVGAAA             * Jump if greater or equal
               B    LWGAAA             * Jump to End
     LVGAAA    MCW  LZEAAA,0+X2        * Move 1 in stack
     LWGAAA    NOP                     * End of GreaterOrEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LRBAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LPBAAA]

     * Assignment ((*(__putchar_last--)) = ' ')
     * Constant (' ' : LXGAAA)
     * Push (LXGAAA:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  LXGAAA,0+X2        * Load data   in stack
     * PostDecrement (__putchar_last--)
     * Push (LYGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYGAAA,0+X2        * Load data 627 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LFFAAA,0+X1        * Postdecrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:1)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * End Assignment ((*(__putchar_last--)) = ' ')

     LPBAAA    NOP                     * Last block instruction
     * End [Block ending at LPBAAA]
     ***************************************

               B    LQBAAA             * Jump to top of While

     LRBAAA    NOP                     * Bottom of While
     * End While [while ((((int) __putchar_last) >= ((int) __putchar_pos))) [Block ending at LPBAAA] top:LQBAAA bottom:LRBAAA]

     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  624,0+X2           * Load memory 624 in stack
     * Push (LYGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYGAAA,0+X2        * Load data 627 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_last = __putchar_pos)

     * Assignment (__putchar_pos = 201)
     * Constant (201 : LZGAAA)
     * Push (LZGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LZGAAA,0+X2        * Load data 201 in stack
     * Push (LUGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUGAAA,0+X2        * Load data 624 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_pos = 201)

     * Start asm block
               W    
     * End asm block
     LOBAAA    NOP                     * Last block instruction
     * End [Block ending at LOBAAA]
     ***************************************

     LTBAAA    NOP                     * Executed when True
     * End If [if ((c != '\n') then [Block ending at LNBAAA] else [Block ending at LOBAAA]]

     * If [if ((__putchar_pos == 333) then [Block ending at LUBAAA]]
     * Equal (__putchar_pos == 333)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  624,0+X2           * Load memory 624 in stack
     * Constant (333 : LCHAAA)
     * Push (LCHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LCHAAA,0+X2        * Load data 333 in stack
               C    0+X2,15997+X2      * Compare stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LAHAAA             * Jump if equal
               B    LBHAAA             * Jump to End
     LAHAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LBHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LVBAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LUBAAA]

     * Assignment (__putchar_last = __putchar_pos)
     * Static Variable (__putchar_pos : 624)
     * Push (624:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  624,0+X2           * Load memory 624 in stack
     * Push (LYGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LYGAAA,0+X2        * Load data 627 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_last = __putchar_pos)

     * Assignment (__putchar_pos = 201)
     * Constant (201 : LZGAAA)
     * Push (LZGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LZGAAA,0+X2        * Load data 201 in stack
     * Push (LUGAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUGAAA,0+X2        * Load data 624 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:3)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End Assignment (__putchar_pos = 201)

     * Start asm block
               W    
     * End asm block
     LUBAAA    NOP                     * Last block instruction
     * End [Block ending at LUBAAA]
     ***************************************

     LVBAAA    NOP                     * Executed when False
     * End If [if ((__putchar_pos == 333) then [Block ending at LUBAAA]]

     LMBAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LMBAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : putchar
     ********************************************************************************

     ********************************************************************************
     * Function : puts
     ********************************************************************************
     LWBAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LXBAAA]

     * Push (3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
     * While [while (((*s) != '\0')) [Block ending at LYBAAA] top:LZBAAA bottom:LACAAA]
     LZBAAA    NOP                     * Top of While
     * NotEqual (!=) ((*s) != '\0')
     * DereferenceExpression (*s)
     * Parameter Variable (s : 15997+X3)
     * Push (15997+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*s)

     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               BE   LDHAAA             * Jump if equal
               B    LEHAAA             * Jump to End
     LDHAAA    MCW  LZEAAA,0+X2        * Move 0 in stack
     LEHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LACAAA,5+X2,       * Jump to bottom of While

     ***************************************
     * Begin [Block ending at LYBAAA]

     * Function Call putchar((*(s++)))
     * Push (5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
     * DereferenceExpression (*(s++))
     * PostIncrement (s++)
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(s++))

     * Create a stack frame with X3 pointer to it
     * Push (X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  X3,0+X2            * Load X3 in stack
               MCW  X2,X3              * Move X2 in X3

               B    LLBAAA             * Jump to function putchar

     * Pop (X3:3)
               LCA  0+X2,X3            * Load stack in X3
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Function Call putchar((*(s++)))

     LYBAAA    NOP                     * Last block instruction
     * End [Block ending at LYBAAA]
     ***************************************

               B    LZBAAA             * Jump to top of While

     LACAAA    NOP                     * Bottom of While
     * End While [while (((*s) != '\0')) [Block ending at LYBAAA] top:LZBAAA bottom:LACAAA]

     LXBAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LXBAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : puts
     ********************************************************************************

     ********************************************************************************
     * Function : strcpy
     ********************************************************************************
     LJAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LKAAAA]

     * Push (3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
     * While [while ((((*(dest++)) = (*(src++))) != '\0')) [] top:LLAAAA bottom:LMAAAA]
     LLAAAA    NOP                     * Top of While
     * NotEqual (!=) (((*(dest++)) = (*(src++))) != '\0')
     * Assignment ((*(dest++)) = (*(src++)))
     * DereferenceExpression (*(src++))
     * PostIncrement (src++)
     * Push (LHHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LHHAAA,0+X2        * Load data I9D in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * End DereferenceExpression (*(src++))

     * PostIncrement (dest++)
     * Push (LUEAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LUEAAA,0+X2        * Load data I9G in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
               MA   LDFAAA,0+X1        * Postincrement pointer at X1
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
               LCA  0+X2,0+X1          * Load stack in memory X1
     * End Assignment ((*(dest++)) = (*(src++)))

     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               BE   LFHAAA             * Jump if equal
               B    LGHAAA             * Jump to End
     LFHAAA    MCW  LZEAAA,0+X2        * Move 0 in stack
     LGHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LMAAAA,5+X2,       * Jump to bottom of While
               B    LLAAAA             * Jump to top of While

     LMAAAA    NOP                     * Bottom of While
     * End While [while ((((*(dest++)) = (*(src++))) != '\0')) [] top:LLAAAA bottom:LMAAAA]

     LKAAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LKAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : strcpy
     ********************************************************************************

     ********************************************************************************
     * Function : strlen
     ********************************************************************************
     LFAAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LGAAAA]
     * len size:5 offset:3

               LCA  LIHAAA,8+X3        * Load int -1 into memory 8+X3
     * Push (8)
               MA   LJHAAA,X2          * Add 8 to stack pointer
     * While [while (((str[(++len)]) != '\0')) [] top:LHAAAA bottom:LIAAAA]
     LHAAAA    NOP                     * Top of While
     * NotEqual (!=) ((str[(++len)]) != '\0')
     * SubScript (str[(++len)])
     * Parameter Variable (str : 15997+X3)
     * Push (15997+X3:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  15997+X3,0+X2      * Load memory 15997+X3 in stack
     * PreIncrement((++len)
     * Push (LJHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LJHAAA,0+X2        * Load data 008 in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
               A    LWEAAA,0+X1        * Preincrement memory at X1
     * Push (0+X1:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * Put raw index on the stack
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               M    15995+X2,6+X2      * Multiply stack at -5 to stack at 6
               SW   2+X2               * Set WM in stack at 2
               LCA  6+X2,15995+X2      * Load stack at 6 in stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Stack top is now array index
               B    NMNPTR             * Jump to snippet number_to_pointer

               MA   0+X2,15997+X2      * Add stack to stack at -3
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Stack top is location in array now
     * End SubScript (str[(++len)])
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Push (0+X1:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  0+X1,0+X2          * Load memory 0+X1 in stack
     * Constant ('\0' : EOS)
     * Push (EOS:1)
               MA   LDFAAA,X2          * Add 1 to stack pointer
               LCA  EOS,0+X2           * Load memory EOS in stack
               C    0+X2,15999+X2      * Compare stack to stack at -1
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Pop (1)
               MA   LFFAAA,X2          * Add -1 to stack pointer
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               BE   LKHAAA             * Jump if equal
               B    LLHAAA             * Jump to End
     LKHAAA    MCW  LZEAAA,0+X2        * Move 0 in stack
     LLHAAA    NOP                     * End of NotEqual
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LIAAAA,5+X2,       * Jump to bottom of While
               B    LHAAAA             * Jump to top of While

     LIAAAA    NOP                     * Bottom of While
     * End While [while (((str[(++len)]) != '\0')) [] top:LHAAAA bottom:LIAAAA]

     * Put on stack return value (len)
     * Local Variable (len : 8+X3)
     * Push (8+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  8+X3,0+X2          * Load memory 8+X3 in stack
     * Pop (15994+X3:5)
               LCA  0+X2,15994+X3      * Load stack in 15994+X3
               MA   LREAAA,X2          * Add -5 to stack pointer

     LGAAAA    NOP                     * Last block instruction
     * Pop (8)
               MA   LEFAAA,X2          * Add -8 to stack pointer
     * End [Block ending at LGAAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : strlen
     ********************************************************************************

     ********************************************************************************
     * Function : test
     ********************************************************************************
     LSDAAA    SBR  3+X3               * Save return address in register B in stack frame (X3)
     * Set the right WM and clear the wrong ones
               SW   1+X3               * Set WM at 1+X3
               CW   2+X3               * Clear WM at 2+X3
               CW   3+X3               * Clear WM at 3+X3

     ***************************************
     * Begin [Block ending at LTDAAA]

     * Push (3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
     * If [if ((pos == 1) then [Block ending at LUDAAA] else [Block ending at LZDAAA]]
     * Equal (pos == 1)
     * Parameter Variable (pos : 15994+X3)
     * Push (15994+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15994+X3,0+X2      * Load memory 15994+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (1 : LWEAAA)
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LMHAAA             * Jump if equal
               B    LNHAAA             * Jump to End
     LMHAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LNHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LEEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LUDAAA]

     * If [if ((pos == 0) then [Block ending at LVDAAA] else [Block ending at LWDAAA]]
     * Equal (pos == 0)
     * Parameter Variable (pos : 15994+X3)
     * Push (15994+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15994+X3,0+X2      * Load memory 15994+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (0 : LZEAAA)
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LOHAAA             * Jump if equal
               B    LPHAAA             * Jump to End
     LOHAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LPHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LXDAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LVDAAA]

     * Assignment (pos = 5)
     * Constant (5 : LQHAAA)
     * Push (LQHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LQHAAA,0+X2        * Load data 00005 in stack
     * Push (LHHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LHHAAA,0+X2        * Load data I9D in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (pos = 5)

     LVDAAA    NOP                     * Last block instruction
     * End [Block ending at LVDAAA]
     ***************************************

               B    LYDAAA             * Jump when true
     LXDAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LWDAAA]

     * Assignment (pos = 4)
     * Constant (4 : LRHAAA)
     * Push (LRHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LRHAAA,0+X2        * Load data 00004 in stack
     * Push (LHHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LHHAAA,0+X2        * Load data I9D in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (pos = 4)

     LWDAAA    NOP                     * Last block instruction
     * End [Block ending at LWDAAA]
     ***************************************

     LYDAAA    NOP                     * Executed when True
     * End If [if ((pos == 0) then [Block ending at LVDAAA] else [Block ending at LWDAAA]]

     LUDAAA    NOP                     * Last block instruction
     * End [Block ending at LUDAAA]
     ***************************************

               B    LFEAAA             * Jump when true
     LEEAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LZDAAA]

     * If [if ((pos == 2) then [Block ending at LAEAAA] else [Block ending at LBEAAA]]
     * Equal (pos == 2)
     * Parameter Variable (pos : 15994+X3)
     * Push (15994+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15994+X3,0+X2      * Load memory 15994+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (2 : LUHAAA)
     * Push (LUHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LUHAAA,0+X2        * Load data 00002 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LSHAAA             * Jump if equal
               B    LTHAAA             * Jump to End
     LSHAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LTHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LCEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LAEAAA]

     * Assignment (pos = 6)
     * Constant (6 : LVHAAA)
     * Push (LVHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LVHAAA,0+X2        * Load data 00006 in stack
     * Push (LHHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LHHAAA,0+X2        * Load data I9D in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (pos = 6)

     LAEAAA    NOP                     * Last block instruction
     * End [Block ending at LAEAAA]
     ***************************************

               B    LDEAAA             * Jump when true
     LCEAAA    NOP                     * Executed when False

     ***************************************
     * Begin [Block ending at LBEAAA]

     * Assignment (pos = 7)
     * Constant (7 : LWHAAA)
     * Push (LWHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWHAAA,0+X2        * Load data 00007 in stack
     * Push (LHHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LHHAAA,0+X2        * Load data I9D in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (pos = 7)

     LBEAAA    NOP                     * Last block instruction
     * End [Block ending at LBEAAA]
     ***************************************

     LDEAAA    NOP                     * Executed when True
     * End If [if ((pos == 2) then [Block ending at LAEAAA] else [Block ending at LBEAAA]]

     LZDAAA    NOP                     * Last block instruction
     * End [Block ending at LZDAAA]
     ***************************************

     LFEAAA    NOP                     * Executed when True
     * End If [if ((pos == 1) then [Block ending at LUDAAA] else [Block ending at LZDAAA]]

     * If [if ((pos == 7) then [Block ending at LGEAAA] else [if ((pos == 6) then [Block ending at LHEAAA]]]
     * Equal (pos == 7)
     * Parameter Variable (pos : 15994+X3)
     * Push (15994+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15994+X3,0+X2      * Load memory 15994+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (7 : LWHAAA)
     * Push (LWHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWHAAA,0+X2        * Load data 00007 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LXHAAA             * Jump if equal
               B    LYHAAA             * Jump to End
     LXHAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LYHAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LJEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LGEAAA]

     * Return to LTDAAA with return value 1
     * Put on stack return value (1)
     * Constant (1 : LWEAAA)
     * Push (LWEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LWEAAA,0+X2        * Load data 00001 in stack
     * Pop (15989+X3:5)
               LCA  0+X2,15989+X3      * Load stack in 15989+X3
               MA   LREAAA,X2          * Add -5 to stack pointer
               B    LTDAAA             * Jump to end of function block

     LGEAAA    NOP                     * Last block instruction
     * End [Block ending at LGEAAA]
     ***************************************

               B    LKEAAA             * Jump when true
     LJEAAA    NOP                     * Executed when False
     * If [if ((pos == 6) then [Block ending at LHEAAA]]
     * Equal (pos == 6)
     * Parameter Variable (pos : 15994+X3)
     * Push (15994+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15994+X3,0+X2      * Load memory 15994+X3 in stack
               B    CLNNMN             * Jump to snippet clean_number

     * Constant (6 : LVHAAA)
     * Push (LVHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LVHAAA,0+X2        * Load data 00006 in stack
               B    CLNNMN             * Jump to snippet clean_number

               C    0+X2,15995+X2      * Compare stack to stack at -5
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
     * Push (LZEAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LZEAAA,0+X2        * Load data 00000 in stack
               BE   LZHAAA             * Jump if equal
               B    LAIAAA             * Jump to End
     LZHAAA    MCW  LWEAAA,0+X2        * Move 1 in stack
     LAIAAA    NOP                     * End of Equal
               MCS  0+X2,0+X2          * Clear WM in stack
     * Pop (5)
               MA   LREAAA,X2          * Add -5 to stack pointer
               BCE  LIEAAA,5+X2,       * Jump when False

     ***************************************
     * Begin [Block ending at LHEAAA]

     * Return to LTDAAA with return value 2
     * Put on stack return value (2)
     * Constant (2 : LUHAAA)
     * Push (LUHAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LUHAAA,0+X2        * Load data 00002 in stack
     * Pop (15989+X3:5)
               LCA  0+X2,15989+X3      * Load stack in 15989+X3
               MA   LREAAA,X2          * Add -5 to stack pointer
               B    LTDAAA             * Jump to end of function block

     LHEAAA    NOP                     * Last block instruction
     * End [Block ending at LHEAAA]
     ***************************************

     LIEAAA    NOP                     * Executed when False
     * End If [if ((pos == 6) then [Block ending at LHEAAA]]

     LKEAAA    NOP                     * Executed when True
     * End If [if ((pos == 7) then [Block ending at LGEAAA] else [if ((pos == 6) then [Block ending at LHEAAA]]]

     * Assignment (pos = 10)
     * Constant (10 : LMGAAA)
     * Push (LMGAAA:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  LMGAAA,0+X2        * Load data 00010 in stack
     * Push (LHHAAA:3)
               MA   LNEAAA,X2          * Add 3 to stack pointer
               LCA  LHHAAA,0+X2        * Load data I9D in stack
               MA   X3,0+X2            * Add X3 to stack
     * Pop (X1:3)
               LCA  0+X2,X1            * Load stack in X1
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * Pop (0+X1:5)
               LCA  0+X2,0+X1          * Load stack in 0+X1
               MA   LREAAA,X2          * Add -5 to stack pointer
     * End Assignment (pos = 10)

     * Put on stack return value (pos)
     * Parameter Variable (pos : 15994+X3)
     * Push (15994+X3:5)
               MA   LPEAAA,X2          * Add 5 to stack pointer
               LCA  15994+X3,0+X2      * Load memory 15994+X3 in stack
     * Pop (15989+X3:5)
               LCA  0+X2,15989+X3      * Load stack in 15989+X3
               MA   LREAAA,X2          * Add -5 to stack pointer

     LTDAAA    NOP                     * Last block instruction
     * Pop (3)
               MA   LUEAAA,X2          * Add -3 to stack pointer
     * End [Block ending at LTDAAA]
     ***************************************

               LCA  3+X3,X1            * Load return address in X1
               B    0+X1               * Jump back to caller in X1

     ********************************************************************************
     * End Function : test
     ********************************************************************************
     ****************************************************************
     ** CLEAN NUMBER SNIPPET                                       **
     ****************************************************************
     
     * Normalizes the zone bits of a number, leaving either A=0B=0
     * for a positive or A=0B=1 for a negative
     CLNNMN    SBR  X1
     * Do nothing on either no zone bits or only a b zone bit
               BWZ  CLNNME,0+X2,2
               BWZ  CLNNME,0+X2,K
     * else clear the zone bits, as it is positive
               MZ   @ @,0+X2
     CLNNME    B    0+X1

     ****************************************************************
     ****************************************************************
     ** DIVISION SNIPPET                                           **
     ****************************************************************
     * SETUP RETURN ADDRESS
     SNPDIV    SBR  DIVEND+3

     * POP DIVIDEND
               MCW  0+X2,CDIV2
               SBR  X2,15995+X2

     * POP DIVISOR
               MCW  0+X2,CDIV1
               SBR  X2,15995+X2


               B    *+17               * Branch 17 places down?

               DCW  @00000@
               DC   @00000000000@

               ZA   CDIV2,*-7        * PUT DIVIDEND INTO WORKING BL
               D    CDIV1,*-19       * DIVIDE
               MZ   *-22,*-21        * KILL THE ZONE BIT
               MZ   *-29,*-34        * KILL THE ZONE BIT
               MCW  *-41,CDIV3       * PICK UP ANSWER
               SW   *-44              * SO I CAN PICKUP REMAINDER
               MCW  *-46,CDIV4       * GET REMAINDER
               CW   *-55              * CLEAR THE WM
               MZ   CDIV3-1,CDIV3    * CLEANUP QUOTIENT BITZONE
               MZ   CDIV4-1,CDIV4    * CLEANUP REMAINDER BITZONE

     * PUSH REMAINDER
               SBR  X2,5+X2
               SW   15996+X2
               MCW  CDIV4,0+X2

     * PUSH QUOTIENT
               SBR  X2,5+X2
               SW   15996+X2
               MCW  CDIV3,0+X2

     * JUMP BACK
     DIVEND    B    000

     * DIVISOR
     CDIV1     DCW  00000
     * DIVIDEND
     CDIV2     DCW  00000
     * QUOTIENT
     CDIV3     DCW  00000
     * REMAINDER
     CDIV4     DCW  00000

     ****************************************************************
     ****************************************************************
     ** CAST NUMBER TO POINTER SNIPPET                             **
     ****************************************************************

     NMNPTR    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   NPHIGH
               C    @08000@,0+X2
               BL   NPLOZ
               C    @12000@,0+X2
               BL   NPLZO
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    NPHIGH
     NPLZO     S    @08000@,0+X2
               MZ   @I@,3+X2
               B    NPHIGH
     NPLOZ     S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     NPHIGH    C    @01000@,0+X2
               BL   NMPTRE
               C    @02000@,0+X2
               BL   NPHOZ
               C    @03000@,0+X2
               BL   NPHZO
               MZ   @A@,1+X2
               B    NMPTRE
     NPHZO     MZ   @I@,1+X2
               B    NMPTRE
     NPHOZ     MZ   @S@,1+X2
     NMPTRE    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1

     ****************************************************************
     ****************************************************************
     ** CAST POINTER TO NUMBER SNIPPET                             **
     ****************************************************************

     PTRNMN    SBR  X1
     * Casts a 3-digit address to a 5-digit number
     * Make room on the stack for an int
               MA   @002@,X2
     * make a copy of the top of the stack
               LCA  15998+X2,3+X2
     * Now zero out the top of the stack
               LCA  @00000@,0+X2
     * Now copy back, shifted over 2 digits
               MCW  3+X2,0+X2
     * Now zero out the zone bits on the stack
               MZ   @0@,0+X2
               MZ   @0@,15999+X2
               MZ   @0@,15998+X2
     * check the high-order digit's zone bits
               BWZ  PNHOZ,1+X2,S
               BWZ  PNHZO,1+X2,K
               BWZ  PNHOO,1+X2,B
               B    PNLOW
     PNHOZ     A    @01000@,0+X2
               B    PNLOW
     PNHZO     A    @02000@,0+X2
               B    PNLOW
     PNHOO     A    @03000@,0+X2
     PNLOW     BWZ  PNLOZ,3+X2,S
               BWZ  PNLZO,3+X2,K
               BWZ  PNLOO,3+X2,B
               B    PTRNME
     PNLOZ     A    @04000@,0+X2
               B    PTRNME
     PNLZO     A    @08000@,0+X2
               B    PTRNME
     PNLOO     A    @12000@,0+X2
     PTRNME    B    0+X1
     
     ****************************************************************

     LAGAAA    DCW  @%@                * Value %
     LCFAAA    DCW  @-@                * Value -
     LCHAAA    DCW  @333@              * Pointer 0
     LDFAAA    DCW  @001@              * Pointer 0
     LEFAAA    DCW  @I9B@              * Pointer 0
     LFFAAA    DCW  @I9I@              * Pointer 0
     LFGAAA    DCW  @C@                * Value C
     LHHAAA    DCW  @I9D@              * Pointer 0
     LIFAAA    DCW  @0@                * Value 0
     LIGAAA    DCW  @S@                * Value S
     LIHAAA    DCW  @0000J@            * Value 0000J
     LJHAAA    DCW  @008@              * Pointer 0
     LLFAAA    DCW  @I8F@              * Pointer 0
     LLGAAA    DCW  @D@                * Value D
     LMFAAA    DCW  @011@              * Pointer 0
     LMGAAA    DCW  @00010@            * Value 00010
     LNEAAA    DCW  @003@              * Pointer 0
     LNFAAA    DCW  @010@              * Pointer 0
     LNGAAA    DCW  @012@              * Pointer 0
     LOEAAA    DCW  @100000@           * Value 100000
     LOFAAA    DCW  @651@              * Pointer 0
     LOGAAA    DCW  @I9C@              * Pointer 0
     LPEAAA    DCW  @005@              * Pointer 0
     LPFAAA    DCW  @659@              * Pointer 0
     LQEAAA    DCW  @00042@            * Value 00042
     LQFAAA    DCW  @668@              * Pointer 0
     LQHAAA    DCW  @00005@            * Value 00005
     LREAAA    DCW  @I9E@              * Pointer 0
     LRFAAA    DCW  @675@              * Pointer 0
     LRGAAA    DCW  @P@                * Value P
     LRHAAA    DCW  @00004@            * Value 00004
     LSEAAA    DCW  @00019@            * Value 00019
     LSFAAA    DCW  @683@              * Pointer 0
     LTEAAA    DCW  @604@              * Pointer 0
     LTFAAA    DCW  @690@              * Pointer 0
     LUEAAA    DCW  @I9G@              * Pointer 0
     LUFAAA    DCW  @I8I@              * Pointer 0
     LUGAAA    DCW  @624@              * Pointer 0
     LUHAAA    DCW  @00002@            * Value 00002
     LVEAAA    DCW  @605@              * Pointer 0
     LVHAAA    DCW  @00006@            * Value 00006
     LWEAAA    DCW  @00001@            * Value 00001
     LWHAAA    DCW  @00007@            * Value 00007
     LXEAAA    DCW  @014@              * Pointer 0
     LXFAAA    DCW  @007@              * Pointer 0
     LXGAAA    DCW  @ @                * Value  
     LYEAAA    DCW  @006@              * Pointer 0
     LYGAAA    DCW  @627@              * Pointer 0
     LZEAAA    DCW  @00000@            * Value 00000
     LZGAAA    DCW  @201@              * Pointer 0

               END  START              * End of program code.
