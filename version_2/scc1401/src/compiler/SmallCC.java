/* SmallCC.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. SmallCC.java */
package compiler;

import java.util.*;
import retree.statement.*;
import retree.expression.*;
import retree.exceptions.*;
import retree.program.*;
import retree.type.*;
import retree.symtab.*;
import retree.intermediate.*;
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Map.Entry;
import static retree.RetreeUtils.*;

public class SmallCC/*@bgen(jjtree)*/implements SmallCCTreeConstants, SmallCCConstants {/*@bgen(jjtree)*/
  protected static JJTSmallCCState jjtree = new JJTSmallCCState();// protected static JJTSmallCCState jjtree = new JJTSmallCCState(); // used during tree build
        private static List<Initializer> stringInits;
        private static int stringLiteralIdx;
        public static SymbolTableStack variableTable;
        public static HashMap<String, ConstantExpression> functionTable;
        // when a function is defined, we stage it here.  Only when it is called do we add it to our program.
        private static HashMap<ConstantExpression, FunctionDefinition> pendingFunctionDefinitions;
        private static HashSet<FunctionDefinition> includedFunctions;
        public static HashMap<String, String> labelTable;
        public static List<Pair<String, String>> arrMemberLabelTable;

        public static String autocoderFile = null;
        public static String compilationTime = null;

        public static boolean inAsmFunc = false;

        public static int stackMem = 400;
        public static int dataMem = 2000;
        public static int codeMem = 0;                                  // if 0 then put the code immediately after the data
        public static boolean reuseStringLiterals = false;
        public static boolean optimize = true;

        private static int labelNumber = 0;
        public static int nextLabelNumber()
        {
                return labelNumber++;
        }

        public static String getLabelForVariable(String var)
        {
                if(labelTable.containsKey(var))
                {
                        String label = labelTable.get(var);
                        return label;
                }
                else
                {
                        String label = label(nextLabelNumber());
                        labelTable.put(var, label);
                        return label;
                }
        }

        public static String getVariableLabelValue(String label)
        {
                for (Entry<String, String> entry : labelTable.entrySet())
                {
                        if (label.equals(entry.getValue()))
                        {
                                return entry.getKey();
                        }
                }

                return null;
        }

        public static String getLabelForArrayMember(String var)
        {
                String label = label(nextLabelNumber());

                @SuppressWarnings("unchecked")
                Pair<String, String> p = new Pair(label, var);
                arrMemberLabelTable.add(p);

                return label;
        }

        public static String getFunctionNameFromExpression(ConstantExpression c)
        {
                for (Map.Entry<String,ConstantExpression> entry : functionTable.entrySet())
                {
                        if (entry.getValue() == c)
                        {
                                return entry.getKey();
                        }
                }

                return "UNNAMED FUNCTION";
        }

        public static void main(String args[]) throws Exception
        {
        if(args.length == 0)
        {
            System.out.println("No input file");
                        System.exit(1);
        }
        else
        {
            System.exit(compile(args[0], null, 0, 0, 0));
        }
        }

        public static int compile(String inputFile, String outputFile, int stackLoc, int codeLoc, int dataLoc) throws Exception
        {
                Snippet.Init();
                // Optimizer.DropComments(true);
        SimpleDateFormat sdf = new SimpleDateFormat("d-MMM-y h:mm:ss a");  // 24 hours -> "d-MMM-y hh:mm:ss";
                compilationTime = sdf.format(Calendar.getInstance().getTime());

                if(stackLoc > 0 && stackLoc < 16000)
                {
                        stackMem = stackLoc;
                }

                if(codeLoc > 0 && codeLoc < 16000)
                {
                        codeMem = codeLoc;
                }

                if(dataLoc > 0 && dataLoc < 16000)
                {
                        dataMem = dataLoc;
                }

                if(outputFile.length() > 0)
                {
                        File f = new File(outputFile);
                        autocoderFile = f.getName();
                }
                else
                {
                        autocoderFile = "";
                }

                System.out.println("Stack: " + stackMem);
                System.out.println("Code: " + codeMem);
                System.out.println("Data: " + dataMem);
                System.out.println("Reuse String Constants: " + (reuseStringLiterals ? "YES" : "NO"));

                File inFile = new File(inputFile);
                Reader sr = new FileReader(inFile);

                stringInits = new ArrayList<Initializer>();
                stringLiteralIdx = 0;
                functionTable = new HashMap<String, ConstantExpression>();
                variableTable = new SymbolTableStack(dataMem);
                pendingFunctionDefinitions = new HashMap<ConstantExpression, FunctionDefinition>();
                includedFunctions = new HashSet<FunctionDefinition>();
                labelTable = new HashMap<String, String>();
                arrMemberLabelTable = new ArrayList<Pair<String, String>>();

                ArrayList<Type> tmp = new ArrayList<Type>();
                tmp.add(new PointerType(Type.charType));
                tmp.add(null);

                int asmFuncNumber = nextLabelNumber();
                functionTable.put("asm", new ConstantExpression(new FunctionType(Type.intType, tmp, true), asmFuncNumber));

                SmallCC parser = new SmallCC(sr);
                try
                {
                        Program program = parser.program();
                        if(program != null)
                        {
                                for (Initializer i : stringInits)
                                {
                                        program.addInitializer(i);
                                }

                                if (errorFree)
                                {
                                        String code = program.generateCode();

                                        if(outputFile != null)
                                        {
                                                File outFile = new File(outputFile);
                                                Writer wr = new FileWriter(outFile);
												
												if(SmallCC.optimize)
												{											
													wr.write(Optimizer.GenerateCode());
												}
												else
												{
													wr.write(code);
												}
												
                                                wr.close();
                                        }
                                        else
                                        {
                                                System.out.print(code);
                                        }
                                }
                        }
                        else
                        {
                                errorFree = false;
                        }
                }
                catch (Exception e)
                {
                        e.printStackTrace();
                        errorFree = false;
                }

                // Node rootNode = jjtree.rootNode();
                // printTree((SimpleNode)rootNode);

                return(errorFree ? 0 : 1);
        }

        private static boolean errorFree = true;

        public static void reportError(Exception e, Token t)
        {
                reportError(e.toString(), t);
        }

        public static void reportError(String m, Token t)
        {
                errorFree = false;
                System.out.println("Error on line " + t.beginLine + " column " + t.beginColumn);
                System.out.println(m);
        }

        public static void printTree(SimpleNode node)
        {
                System.out.println("===== AST (parse tree) =====");

                printTree(node, 0);
        }

        public static void printTree(SimpleNode node, int level)
        {
                for(int i = 0; i < level; ++i)
                {
                        System.out.print("    ");
                }

                //MyNode n = (MyNode) node;
                //int kind = n.getKind();
                //String name = n.getName();

                String begin = String.format("<%s>", node.toString());
                System.out.println(begin);

                // System.out.println(kind);
                //if(kind == 49 || kind == 50 || kind == 51 || kind == 52 || kind == 15)
                //{
                        //for(int i = 0; i < level; ++i)
                        //{
                        //	System.out.print("    ");
                        //}

                        // System.out.println("    " + node.value);
                //}

                int numChildren = node.jjtGetNumChildren();
                for(int i = 0; i < numChildren; ++i)
                {
                        printTree((SimpleNode) node.jjtGetChild(i), level + 1);
                }

                for(int i = 0; i < level; ++i)
                {
                        System.out.print("    ");
                }

                String end = String.format("</%s>", node.toString());
                System.out.println(end);
        }

/** Main production. */
  static final public 
Program program() throws ParseException, Exception {/*@bgen(jjtree) program */
        SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Program program = new Program();
        List<Initializer> initList = new ArrayList<Initializer>();
        FunctionDefinition func;
    try {
      label_1:
      while (true) {
        if (jj_2_1(99999)) {
          ;
        } else {
          break label_1;
        }
        if (jj_2_2(99999)) {
          initList = globalVariableDeclaration();
//System.out.println(initList.size());
                                for (Initializer init : initList) {
                                        program.addInitializer(init);
                                }
        } else if (jj_2_3(99999)) {
          functionDeclaration();
        } else if (jj_2_4(99999)) {
          func = functionDefinition();
pendingFunctionDefinitions.put(func.getDeclaration(), func);
                                        //program.addFunction(func);

        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
ConstantExpression mainDec = functionTable.get("main");
                                if (mainDec == null) {
                                        System.out.println("Missing main function");
                                        {if ("" != null) return null;}
                                }
                                if (pendingFunctionDefinitions.containsKey(mainDec)) {
                                        includedFunctions.add(pendingFunctionDefinitions.remove(mainDec));
                                }
                                int mainLabelNumber = mainDec.getValue();
                                for (FunctionDefinition def : includedFunctions) {
                                        program.addFunction(def);
                                }
                                program.setMainLabelNumber(mainLabelNumber);

                                {if ("" != null) return program;}
    } catch (Throwable jjte000) {
if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Type bareType() throws ParseException {/*@bgen(jjtree) bareType */
  SimpleNode jjtn000 = new SimpleNode(JJTBARETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_5(99999)) {
        jj_consume_token(CHAR);
jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
{if ("" != null) return Type.charType;}
      } else if (jj_2_6(99999)) {
        jj_consume_token(INT);
jjtree.closeNodeScope(jjtn000, true);
                                            jjtc000 = false;
{if ("" != null) return Type.intType;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Type Type() throws ParseException {/*@bgen(jjtree) Type */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Type t;
    try {
      t = bareType();
      label_2:
      while (true) {
        if (jj_2_7(99999)) {
          ;
        } else {
          break label_2;
        }
        jj_consume_token(STAR);
t = new PointerType(t);
      }
jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
{if ("" != null) return t;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public List<Initializer> globalVariableDeclaration() throws ParseException {/*@bgen(jjtree) globalVariableDeclaration */
                SimpleNode jjtn000 = new SimpleNode(JJTGLOBALVARIABLEDECLARATION);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);List<Initializer> inits = new ArrayList<Initializer>();
                Type baseType = Type.intType;
    try {
      if (jj_2_8(99999)) {
        baseType = bareType();
      } else {
        ;
      }
      inits = variableDeclarationList(baseType, true);
      jj_consume_token(SEMI_COLON);
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return inits;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public List<Initializer> localVariableDeclaration() throws ParseException {/*@bgen(jjtree) localVariableDeclaration */
        SimpleNode jjtn000 = new SimpleNode(JJTLOCALVARIABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<Initializer> initializers;
        Type baseType;
    try {
      baseType = bareType();
      initializers = variableDeclarationList(baseType, false);
      jj_consume_token(SEMI_COLON);
jjtree.closeNodeScope(jjtn000, true);
                                                                                            jjtc000 = false;
{if ("" != null) return initializers;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public List<Initializer> variableDeclarationList(Type baseType, boolean isStatic) throws ParseException {/*@bgen(jjtree) variableDeclarationList */
        SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATIONLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<Initializer> inits = new ArrayList<Initializer>();
        Initializer init;
    try {
      init = variableInitializer(baseType, isStatic);
inits.add(init);
      label_3:
      while (true) {
        if (jj_2_9(99999)) {
          ;
        } else {
          break label_3;
        }
        jj_consume_token(60);
        init = variableInitializer(baseType, isStatic);
inits.add(init);
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return inits;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Initializer variableInitializer(Type baseType, boolean isStatic) throws ParseException {/*@bgen(jjtree) variableInitializer */
        SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEINITIALIZER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Initializer init = null;
        VariableExpression variable;
        Expression value = null;
        Token t = null;
    try {
      //ternaryExpression, since we can't have a comma-separated or assignment expression
              variable = suffixedVariable(baseType, isStatic);
      if (jj_2_10(99999)) {
        jj_consume_token(EQUALS);
t=token;
        value = ternaryExpression();
      } else {
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
try {
                        {if ("" != null) return new Initializer(variable, value, false);}
                } catch(Exception e) {
                        reportError(e, t);
                        {if ("" != null) return new Initializer(variable, (Expression)null, false);}
                }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//here is where we add it to our SymbolTable, since we know
//the full type
  static final public VariableExpression suffixedVariable(Type baseType, boolean isStatic) throws ParseException {/*@bgen(jjtree) suffixedVariable */
        SimpleNode jjtn000 = new SimpleNode(JJTSUFFIXEDVARIABLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Pair<Type,String> pair;
        Expression arraySize = null;
        int size = -1;
        Type type;
        Expression variable;
    try {
      if (jj_2_11(99999)) {
        pair = PrefixedVariable(baseType);
        jj_consume_token(61);
        arraySize = expression();
        jj_consume_token(62);
arraySize = arraySize.collapse();
                if (!(arraySize instanceof ConstantExpression)) {
                        System.out.println("Array size is not a constant!");
                        {if (true) throw new NonConstantExpressionException(arraySize);}
                }
                size = ((ConstantExpression) arraySize).getValue();
                type = new ArrayType(size, pair.a);
      } else if (jj_2_12(99999)) {
        pair = PrefixedVariable(baseType);
type = pair.a;
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
if (isStatic) {
                        {if ("" != null) return SmallCC.variableTable.addStatic(pair.b, type);}
                } else {
                        {if ("" != null) return SmallCC.variableTable.add(pair.b,type, false);}
                }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Pair<Type,String> PrefixedVariable(Type baseType) throws ParseException {/*@bgen(jjtree) PrefixedVariable */
        SimpleNode jjtn000 = new SimpleNode(JJTPREFIXEDVARIABLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Pair<Type,String> pair = new Pair<Type,String>();
        pair.a = baseType;
    try {
      if (jj_2_13(99999)) {
        pair.b = Identifier();
      } else if (jj_2_14(99999)) {
        jj_consume_token(STAR);
        pair = PrefixedVariable(new PointerType(baseType));
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return pair;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void functionDeclaration() throws ParseException {/*@bgen(jjtree) functionDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Type();
      Identifier();
      jj_consume_token(L_PAREN);
      if (jj_2_16(99999)) {
        FunctionDeclarationParameter();
        label_4:
        while (true) {
          if (jj_2_15(99999)) {
            ;
          } else {
            break label_4;
          }
          jj_consume_token(60);
          FunctionDeclarationParameter();
        }
      } else {
        ;
      }
      jj_consume_token(R_PAREN);
      jj_consume_token(SEMI_COLON);
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;

    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void FunctionDeclarationParameter() throws ParseException {/*@bgen(jjtree) FunctionDeclarationParameter */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDECLARATIONPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_18(99999)) {
        Type();
        if (jj_2_17(99999)) {
          Identifier();
        } else {
          ;
        }
      } else if (jj_2_19(99999)) {
        Identifier();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_21(99999)) {
        jj_consume_token(61);
        if (jj_2_20(99999)) {
          expression();
        } else {
          ;
        }
        jj_consume_token(62);
      } else {
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public FunctionDefinition functionDefinition() throws ParseException {/*@bgen(jjtree) functionDefinition */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDEFINITION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Type retType = Type.intType;
        List<VariableExpression> parameters = new ArrayList<VariableExpression>();
        VariableExpression param;
        FunctionType type;
        String name;
        BlockStatement block;
        variableTable.push();

        try {
                //this is the function's return address.
                //stored under an empty identifier, so no variable can collide with it
                //the value will be assigned automatically.
                variableTable.add("", new PointerType(Type.charType), false);
        } catch(Exception e) {
                reportError("we should never be here 1", token);
        }
    try {
      if (jj_2_22(99999)) {
        retType = Type();
      } else {
        ;
      }
      name = Identifier();
if(name.equals("asm")){inAsmFunc = true;}else{inAsmFunc = false;}
      jj_consume_token(L_PAREN);
      if (jj_2_24(99999)) {
        param = functionDefinitionParameter(parameters.size());
parameters.add(param);
        label_5:
        while (true) {
          if (jj_2_23(99999)) {
            ;
          } else {
            break label_5;
          }
          jj_consume_token(60);
          param = functionDefinitionParameter(parameters.size());
parameters.add(param);
        }
      } else {
        ;
      }
      if (jj_2_25(99999)) {
        jj_consume_token(60);
        jj_consume_token(63);
parameters.add(null);
      } else {
        ;
      }
      jj_consume_token(R_PAREN);
List<Type> paramTypes = new ArrayList<Type>();
                        boolean variadic = false;
                        for (VariableExpression p : parameters) {
                                if (p == null) {
                                        variadic = true;
                                        paramTypes.add(null);
                                        break;
                                }
                                paramTypes.add(p.getType());
                        }
                        if (!variadic) {
                                //we're calling the location of the return value "return"
                                variableTable.add("return", retType, true);
                        }

                        type = new FunctionType(retType, paramTypes, variadic);
                        ConstantExpression dec = functionTable.get(name);
                        if (dec != null) {
                                if (! dec.getType().equals(type)) {
                                        {if (true) throw new Error("Type mismatch: function " + name +
                                                "was previously declared as type " + dec.getType());}
                                }
                        } else {
                                dec = new ConstantExpression(type, nextLabelNumber());
                                functionTable.put(name, dec);
                        }
      //we provide no return label - this is a top-level block.
              block = blockStatement(true, null);
jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
variableTable.pop();
                        {if ("" != null) return new FunctionDefinition(dec, block);}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public VariableExpression functionDefinitionParameter(int paramNum) throws ParseException {/*@bgen(jjtree) functionDefinitionParameter */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDEFINITIONPARAMETER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Type type = Type.intType;
        String name;
    try {
      if (jj_2_26(99999)) {
        type = Type();
      } else {
        ;
      }
      name = Identifier();
      if (jj_2_28(99999)) {
        jj_consume_token(61);
        if (jj_2_27(99999)) {
          expression();
        } else {
          ;
        }
        jj_consume_token(62);
//in function parameters, array types are literally just pointer types.
                type = new PointerType(type);
      } else {
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
if (variableTable.searchTop(name) != null) {
                        {if (true) throw new Error("Redefinition of variable " + name);}
                }
                {if ("" != null) return variableTable.add(name, type, true);}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public BlockStatement blockStatement(boolean isFunction, String returnLabel) throws ParseException {/*@bgen(jjtree) blockStatement */
        SimpleNode jjtn000 = new SimpleNode(JJTBLOCKSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<Initializer> initializers = new ArrayList<Initializer>();
        List<Statement> statements = new ArrayList<Statement>();
        List<Initializer> initList;
        String newReturnLabel = label(nextLabelNumber());
        Statement s;
        if (isFunction) {
                try {
                        initializers.add(new Initializer(variableTable.searchStack(""), (Expression) null, false));
                } catch (Exception e) {
                        reportError("We should never be here 0", token);
                }
        }
    try {
//functions have already pushed, and will pop after
                if (!isFunction) variableTable.push();
      jj_consume_token(64);
      label_6:
      while (true) {
        if (jj_2_29(99999)) {
          ;
        } else {
          break label_6;
        }
        initList = localVariableDeclaration();
for (Initializer init : initList) {
                        initializers.add(init);
                }
      }
      label_7:
      while (true) {
        if (jj_2_30(99999)) {
          ;
        } else {
          break label_7;
        }
        s = statement(newReturnLabel);
statements.add(s);
      }
      jj_consume_token(65);
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
//System.out.println(variableTable.peek().getStackOffset());
                BlockStatement bs = new BlockStatement(initializers, statements, variableTable.peek().getLocalSize(), newReturnLabel, returnLabel);
                if (!isFunction) {
                        variableTable.pop();
                }
                {if ("" != null) return bs;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Statement statement(String returnLabel) throws ParseException {/*@bgen(jjtree) statement */
        SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Statement stat, stat2 = null;
        Expression exp=null, exp2=null, exp3=null;
    try {
      if (jj_2_39(99999)) {
        jj_consume_token(SEMI_COLON);
jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
{if ("" != null) return new EmptyStatement();}
      } else if (jj_2_40(99999)) {
        exp = expression();
        jj_consume_token(SEMI_COLON);
jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
{if ("" != null) return new ExpressionStatement(exp);}
      } else if (jj_2_41(99999)) {
        stat = blockStatement(false, returnLabel);
jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
{if ("" != null) return stat;}
      } else if (jj_2_42(99999)) {
        jj_consume_token(IF);
        jj_consume_token(L_PAREN);
        exp = expression();
        jj_consume_token(R_PAREN);
        stat = statement(returnLabel);
        if (jj_2_31(99999)) {
          jj_consume_token(ELSE);
          stat2 = statement(returnLabel);
        } else {
          ;
        }
jjtree.closeNodeScope(jjtn000, true);
                                                                                                          jjtc000 = false;
{if ("" != null) return new IfStatement(exp, stat, stat2);}
      } else if (jj_2_43(99999)) {
        jj_consume_token(WHILE);
        jj_consume_token(L_PAREN);
        exp = expression();
        jj_consume_token(R_PAREN);
        stat = statement(returnLabel);
jjtree.closeNodeScope(jjtn000, true);
                                                                     jjtc000 = false;
{if ("" != null) return new WhileStatement(exp, stat);}
      } else if (jj_2_44(99999)) {
        jj_consume_token(FOR);
        jj_consume_token(L_PAREN);
        if (jj_2_32(99999)) {
          exp = expression();
          jj_consume_token(SEMI_COLON);
        } else if (jj_2_33(99999)) {
          jj_consume_token(SEMI_COLON);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_34(99999)) {
          exp2 = expression();
          jj_consume_token(SEMI_COLON);
        } else if (jj_2_35(99999)) {
          jj_consume_token(SEMI_COLON);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_36(99999)) {
          exp3 = expression();
          jj_consume_token(R_PAREN);
        } else if (jj_2_37(99999)) {
          jj_consume_token(R_PAREN);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        stat = statement(returnLabel);
jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                        jjtc000 = false;
{if ("" != null) return new ForStatement(exp, exp2, exp3, stat);}
      } else if (jj_2_45(99999)) {
        jj_consume_token(DO);
        stat = statement(returnLabel);
        jj_consume_token(WHILE);
        jj_consume_token(L_PAREN);
        exp = expression();
        jj_consume_token(R_PAREN);
        jj_consume_token(SEMI_COLON);
jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
{if ("" != null) return new DoWhileStatement(exp, stat);}
      } else if (jj_2_46(99999)) {
        jj_consume_token(RETURN);
        if (jj_2_38(99999)) {
          exp = expression();
        } else {
          ;
        }
        jj_consume_token(SEMI_COLON);
jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
{if ("" != null) return new ReturnStatement(exp, variableTable.searchStack("return"), returnLabel);}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

/*
void CaseStatement() : {}
{
	(("case" expression() | "default") ":" (CaseStatement() | statement()))
}

void CaseBlock() : {}
{
	"{" (localVariableDeclaration())* (statement() | CaseStatement()) * "}"
}
*/
/** Left-to-right*/
  static final public Expression expression() throws ParseException {/*@bgen(jjtree) expression */
        SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null;
        Expression r = null;
    try {
      l = assignmentExpression();
      label_8:
      while (true) {
        if (jj_2_47(99999)) {
          ;
        } else {
          break label_8;
        }
        jj_consume_token(60);
        r = assignmentExpression();
l = new CommaExpression(l, r);
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/** Right-to-left */
  static final public Expression assignmentExpression() throws ParseException {/*@bgen(jjtree) assignmentExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
        Token lToken = null;
        try {
                lToken = getToken(1);
        } catch(Exception e) {
                reportError("Unexpected end of file.", token);
        }
    try {
      l = ternaryExpression();
      if (jj_2_59(99999)) {
        if (jj_2_48(99999)) {
          jj_consume_token(66);
          r = assignmentExpression();
r = new AddExpression(l, r);
        } else if (jj_2_49(99999)) {
          jj_consume_token(67);
          r = assignmentExpression();
r = new SubtractExpression(l, r);
        } else if (jj_2_50(99999)) {
          jj_consume_token(68);
          r = assignmentExpression();
r = new MultiplyExpression(l, r);
        } else if (jj_2_51(99999)) {
          jj_consume_token(69);
          r = assignmentExpression();
r = new DivideExpression(l, r);
        } else if (jj_2_52(99999)) {
          jj_consume_token(70);
          r = assignmentExpression();
r = new ModuloExpression(l, r);
        } else if (jj_2_53(99999)) {
          jj_consume_token(71);
          r = assignmentExpression();

        } else if (jj_2_54(99999)) {
          jj_consume_token(72);
          r = assignmentExpression();

        } else if (jj_2_55(99999)) {
          jj_consume_token(73);
          r = assignmentExpression();

        } else if (jj_2_56(99999)) {
          jj_consume_token(74);
          r = assignmentExpression();

        } else if (jj_2_57(99999)) {
          jj_consume_token(75);
          r = assignmentExpression();

        } else if (jj_2_58(99999)) {
          jj_consume_token(EQUALS);
          r = assignmentExpression();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
if (r != null) {
                                        if (l instanceof LValue)
                                                try {
                                                        {if ("" != null) return new AssignmentExpression((LValue)l, r);}
                                                } catch (TypeMismatchException e) {
                                                        reportError(e, lToken);
                                                }
                                        else reportError("Left side of assignment must be an lvalue.", lToken);
                                }
                                {if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression ternaryExpression() throws ParseException {/*@bgen(jjtree) ternaryExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTTERNARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, t = null, f = null;
    try {
      l = orExpression();
      if (jj_2_60(99999)) {
        jj_consume_token(76);
        t = expression();
        jj_consume_token(77);
        f = ternaryExpression();
      } else {
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
if (t != null && f != null)
                {
                        try {
                                {if ("" != null) return new TernaryExpression(l,t,f);}
                        } catch (TypeMismatchException e) {
                                reportError(e, token);
                                {if ("" != null) return null;}
                        }
                }
                {if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/** left-to-right*/
  static final public 
Expression orExpression() throws ParseException {/*@bgen(jjtree) orExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = andExpression();
      label_9:
      while (true) {
        if (jj_2_61(99999)) {
          ;
        } else {
          break label_9;
        }
        jj_consume_token(BOOLEAN_OR);
        r = andExpression();
l = new OrExpression(l, r);
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression andExpression() throws ParseException {/*@bgen(jjtree) andExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTANDEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = bitOrExpression();
      label_10:
      while (true) {
        if (jj_2_62(99999)) {
          ;
        } else {
          break label_10;
        }
        jj_consume_token(BOOLEAN_AND);
        r = bitOrExpression();
l = new AndExpression(l, r);
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression bitOrExpression() throws ParseException {/*@bgen(jjtree) bitOrExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = bitXorExpression();
      label_11:
      while (true) {
        if (jj_2_63(99999)) {
          ;
        } else {
          break label_11;
        }
        jj_consume_token(BIT_OR);
        r = bitXorExpression();

      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression bitXorExpression() throws ParseException {/*@bgen(jjtree) bitXorExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITXOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = bitAndExpression();
      label_12:
      while (true) {
        if (jj_2_64(99999)) {
          ;
        } else {
          break label_12;
        }
        jj_consume_token(BIT_XOR);
        r = bitAndExpression();

      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression bitAndExpression() throws ParseException {/*@bgen(jjtree) bitAndExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITANDEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = equalityExpression();
      label_13:
      while (true) {
        if (jj_2_65(99999)) {
          ;
        } else {
          break label_13;
        }
        jj_consume_token(BIT_AND);
        r = equalityExpression();

      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression equalityExpression() throws ParseException {/*@bgen(jjtree) equalityExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTEQUALITYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = greaterThanExpression();
      label_14:
      while (true) {
        if (jj_2_66(99999)) {
          ;
        } else {
          break label_14;
        }
        if (jj_2_67(99999)) {
          jj_consume_token(EQUALS_EQUALS);
          r = greaterThanExpression();
try {
                        l = new EqualExpression(l, r);
                        } catch(TypeMismatchException e) {
                                reportError(e, token);
                        }
        } else if (jj_2_68(99999)) {
          jj_consume_token(NOT_EQUALS);
          r = greaterThanExpression();
l = new NotEqualExpression(l, r);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression greaterThanExpression() throws ParseException {/*@bgen(jjtree) greaterThanExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTGREATERTHANEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = lessThanExpression();
      label_15:
      while (true) {
        if (jj_2_69(99999)) {
          ;
        } else {
          break label_15;
        }
        if (jj_2_70(99999)) {
          jj_consume_token(GREATER_THAN);
          r = lessThanExpression();
l = new GreaterThanExpression(l, r);
        } else if (jj_2_71(99999)) {
          jj_consume_token(78);
          r = lessThanExpression();
l = new GreaterThanOrEqualExpression(l, r);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression lessThanExpression() throws ParseException {/*@bgen(jjtree) lessThanExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTLESSTHANEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = bitshiftExpression();
      label_16:
      while (true) {
        if (jj_2_72(99999)) {
          ;
        } else {
          break label_16;
        }
        if (jj_2_73(99999)) {
          jj_consume_token(LESS_THAN);
          r = bitshiftExpression();
l = new LessThanExpression(l, r);
        } else if (jj_2_74(99999)) {
          jj_consume_token(79);
          r = bitshiftExpression();
l = new LessThanOrEqualExpression(l, r);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression bitshiftExpression() throws ParseException {/*@bgen(jjtree) bitshiftExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITSHIFTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = additiveExpression();
      label_17:
      while (true) {
        if (jj_2_75(99999)) {
          ;
        } else {
          break label_17;
        }
        if (jj_2_76(99999)) {
          jj_consume_token(LEFT_SHIFT);
          r = additiveExpression();

        } else if (jj_2_77(99999)) {
          jj_consume_token(RIGHT_SHIFT);
          r = additiveExpression();

        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression additiveExpression() throws ParseException {/*@bgen(jjtree) additiveExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = multiplicativeExpression();
      label_18:
      while (true) {
        if (jj_2_78(99999)) {
          ;
        } else {
          break label_18;
        }
        if (jj_2_79(99999)) {
          jj_consume_token(PLUS);
          r = multiplicativeExpression();
l = new AddExpression(l, r);
        } else if (jj_2_80(99999)) {
          jj_consume_token(MINUS);
          r = multiplicativeExpression();
l = new SubtractExpression(l, r);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression multiplicativeExpression() throws ParseException {/*@bgen(jjtree) multiplicativeExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression l = null, r = null;
    try {
      l = prefixExpression();
      label_19:
      while (true) {
        if (jj_2_81(99999)) {
          ;
        } else {
          break label_19;
        }
        if (jj_2_82(99999)) {
          jj_consume_token(STAR);
          r = prefixExpression();
l = new MultiplyExpression(l, r);
        } else if (jj_2_83(99999)) {
          jj_consume_token(DIVIDE);
          r = prefixExpression();
l = new DivideExpression(l, r);
        } else if (jj_2_84(99999)) {
          jj_consume_token(MOD);
          r = prefixExpression();
l = new ModuloExpression(l, r);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return l;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression prefixExpression() throws ParseException {/*@bgen(jjtree) prefixExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTPREFIXEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression e = null;
        Type t;
    try {
      if (jj_2_85(99999)) {
        e = suffixExpression();
      } else if (jj_2_86(99999)) {
        jj_consume_token(PLUS_PLUS);
        e = prefixExpression();
{if ("" != null) return new PreIncrementExpression((LValue)e);}
      } else if (jj_2_87(99999)) {
        jj_consume_token(MINUS_MINUS);
        e = prefixExpression();
{if ("" != null) return new PreDecrementExpression((LValue)e);}
      } else if (jj_2_88(99999)) {
        jj_consume_token(PLUS);
        e = prefixExpression();

      } else if (jj_2_89(99999)) {
        jj_consume_token(MINUS);
        e = prefixExpression();
e = new NegExpression(e);
      } else if (jj_2_90(99999)) {
        jj_consume_token(BOOLEAN_NOT);
        e = prefixExpression();
e = new NotExpression(e);
      } else if (jj_2_91(99999)) {
        jj_consume_token(BIT_NOT);
        e = prefixExpression();

      } else if (jj_2_92(99999)) {
        jj_consume_token(STAR);
        e = prefixExpression();
{if ("" != null) return new DereferenceExpression(e);}
      } else if (jj_2_93(99999)) {
        jj_consume_token(BIT_AND);
        e = prefixExpression();
// &array_name == array_name
                        if (! (e instanceof ArrayNameExpression)) {
                                {if ("" != null) return new AddressOfExpression((LValue)e);}
                        }
      } else if (jj_2_94(99999)) {
        jj_consume_token(SIZEOF);
        e = prefixExpression();
{if ("" != null) return new ConstantExpression(Type.intType, e.getType().sizeof());}
      } else if (jj_2_95(99999)) {
        jj_consume_token(SIZEOF);
        jj_consume_token(L_PAREN);
        t = Type();
        jj_consume_token(R_PAREN);
{if ("" != null) return new ConstantExpression(Type.intType, t.sizeof());}
      } else if (jj_2_96(99999)) {
        jj_consume_token(L_PAREN);
        t = Type();
        jj_consume_token(R_PAREN);
        e = prefixExpression();
{if ("" != null) return new CastExpression(t,e);}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return e;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression suffixExpression() throws ParseException {/*@bgen(jjtree) suffixExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTSUFFIXEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String s = "";
        Expression e, inside;
        List<Expression> arguments;
    try {
      e = AtomicExpression();
if((e.getType() instanceof FunctionType) && ((ConstantExpression)e).getValue() == 0) { e = new AssemblyExpression(); inAsmFunc = true;}else {inAsmFunc = false;}
      label_20:
      while (true) {
        if (jj_2_97(99999)) {
          ;
        } else {
          break label_20;
        }
        if (jj_2_98(99999)) {
          jj_consume_token(PLUS_PLUS);
try {
                                        e = new PostIncrementExpression((LValue)e);
                                } catch (Exception ex) {
                                        reportError("Expression " + e + "is not an LValue", token);
                                }
        } else if (jj_2_99(99999)) {
          jj_consume_token(MINUS_MINUS);
try {
                                        e = new PostDecrementExpression((LValue)e);
                                } catch (Exception ex) {
                                        reportError("Expression " + e + "is not an LValue", token);
                                }
        } else if (jj_2_100(99999)) {
          jj_consume_token(L_PAREN);
          arguments = expressionList(e);
          jj_consume_token(R_PAREN);
if (!(e instanceof AssemblyExpression)) {
                                        e = new FunctionCallExpression(e,arguments);
                                }
        } else if (jj_2_101(99999)) {
          jj_consume_token(61);
          inside = expression();
          jj_consume_token(62);
e = new SubscriptExpression(e, inside);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
{if ("" != null) return e;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public List<Expression> expressionList(Expression e) throws ParseException {/*@bgen(jjtree) expressionList */
        SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);List<Expression> list = new ArrayList<Expression>();
        Expression exp;
    try {
      if (jj_2_103(99999)) {
        exp = assignmentExpression();
if ((e instanceof AssemblyExpression))
                {
                        ((AssemblyExpression)e).addASM(token.image);
                }
                else
                {
                        list.add(exp);
                }
        label_21:
        while (true) {
          if (jj_2_102(99999)) {
            ;
          } else {
            break label_21;
          }
          jj_consume_token(60);
          exp = assignmentExpression();
if ((e instanceof AssemblyExpression))
                {
                        ((AssemblyExpression)e).addASM(token.image);
                }
                else
                {
                        list.add(exp);
                }
        }
      } else {
        ;
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return list;}
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Expression AtomicExpression() throws ParseException {/*@bgen(jjtree) AtomicExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTATOMICEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Expression e = null;
        ConstantExpression ce = null;
        String str = "";
    try {
      if (jj_2_104(99999)) {
        str = Identifier();
VariableExpression var = variableTable.searchStack(str);
                if (var == null)
                {
                        ConstantExpression fun = functionTable.get(str);
                        if (fun == null)
                        {
                                reportError("Did not find: " + str + " anywhere did you forget to declare it?", token);
                                {if ("" != null) return null;}
                        }
                        else
                        {
                                if (pendingFunctionDefinitions.containsKey(fun))
                                {
                                        //lazily add our function definition to the program
                                        includedFunctions.add(pendingFunctionDefinitions.remove(fun));
                                }
                                {if ("" != null) return fun;}
                        }
                }
                else if (var.getType() instanceof ArrayType)
                {
                        {if ("" != null) return new ArrayNameExpression(var);}
                }
                else
                {
                        {if ("" != null) return var;}
                }
      } else if (jj_2_105(99999)) {
        str = Number();
int val = Integer.parseInt(str);
                ce = new ConstantExpression(Type.intType, val);
                e = ce;
      } else if (jj_2_106(99999)) {
        str = StringLiteral();
// Use the string value as identifier if string constants can be reused otherwise define an unique identifier
                String identif = reuseStringLiterals ? str : "STR_LIT_" + Integer.toString(++stringLiteralIdx);

                VariableExpression ve = variableTable.searchStack(str);
                if (ve != null)
                {
                        ArrayNameExpression ane = new ArrayNameExpression(ve);
                        {if ("" != null) return ane;}
                }
                else
                {
                        str = str.substring(1, str.length() - 1);

                        List<Expression> list = new ArrayList<Expression>();
                        List<Expression> rlist = new ArrayList<Expression>();

                        for(int i = 0; i < str.length(); i++)
                        {
                                if (str.charAt(i) == '\u005c\u005c')
                                {
                                        if(i < str.length() - 1)
                                        {
                                                switch(str.charAt(i+1))
                                                {
                                                        case 'n':
                                                                list.add(new ConstantExpression(Type.charType, '\u005cn'));
                                                                break;
                                                        case '0':
                                                                list.add(new ConstantExpression(Type.charType, 0));
                                                                break;
                                                }
                                                i++;
                                        }
                                }
                                else
                                 {
                                        list.add(new ConstantExpression(Type.charType,("" + str.charAt(i)).toUpperCase().charAt(0)));
                                }
                        }
                        list.add(new ConstantExpression(Type.charType, 0));

                        for (int i = list.size() - 1; i >= 0; i--)
                        {
                                rlist.add(list.get(i));
                        }
                        // need the +1 for the '\0' char

                        ve = variableTable.addStatic(identif, new ArrayType(rlist.size(), Type.charType));

                        ArrayNameExpression ane = new ArrayNameExpression(ve);
                        if (!inAsmFunc)
                        {
                                stringInits.add(new Initializer(ve, rlist));
                        }

                        {if ("" != null) return ane;}
                }
                // check symtab for this string
                // if it is Put that in arry name expr and ret that
                // get list of const expr
                // add to static symtab if not there
                // var with arrtype len  = len of list
                // arry name expr wrap the varexpr enter it key token text with quotes
                // type = arr type
                // add to private list initilzer for string
                // end add to program b4 code gen
                // return array name
                //

      } else if (jj_2_107(99999)) {
        str = CharacterConstant();
int val = 0;
                        //strip the quote characters
                        str = str.substring(1, str.length() - 1);
                        if (str.charAt(0) == '\u005c\u005c')
                        {
                                if (str.length() != 2)
                                {
                                        //invalid char constant
                                        {if ("" != null) return null;}
                                }
                                switch(str.charAt(1))
                                {
                                        case 'n':
                                                val = '\u005cn';
                                                break;
                                        case '0':
                                                val = 0;
                                                break;
                                }
                        }
                        else
                        {
                                if (str.length() != 1)
                                {
                                        //invalid char constant.
                                        {if ("" != null) return null;}
                                }
                                val = Character.toUpperCase(str.charAt(0));
                        }
                ce = new ConstantExpression(Type.charType, val);
                e = ce;
      } else if (jj_2_108(99999)) {
        jj_consume_token(L_PAREN);
        e = expression();
        jj_consume_token(R_PAREN);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return e;}
    } catch (Throwable jjte000) {
if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String Identifier() throws ParseException {/*@bgen(jjtree) Identifier */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
{if ("" != null) return token.image;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String CharacterConstant() throws ParseException {/*@bgen(jjtree) CharacterConstant */
  SimpleNode jjtn000 = new SimpleNode(JJTCHARACTERCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CHARACTER_CONST);
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
//System.out.println("char: " + token.image);
                {if ("" != null) return token.image;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String Number() throws ParseException {/*@bgen(jjtree) Number */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(NUMBER);
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return token.image;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String StringLiteral() throws ParseException {/*@bgen(jjtree) StringLiteral */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(STRING_LIT);
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
{if ("" != null) return token.image;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void Boolean_Not() throws ParseException {/*@bgen(jjtree) Boolean_Not */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN_NOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BOOLEAN_NOT);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Boolean_And() throws ParseException {/*@bgen(jjtree) Boolean_And */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN_AND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BOOLEAN_AND);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Boolean_Or() throws ParseException {/*@bgen(jjtree) Boolean_Or */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN_OR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BOOLEAN_OR);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Bit_Not() throws ParseException {/*@bgen(jjtree) Bit_Not */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_NOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BIT_NOT);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Bit_And() throws ParseException {/*@bgen(jjtree) Bit_And */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_AND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BIT_AND);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Bit_Or() throws ParseException {/*@bgen(jjtree) Bit_Or */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_OR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BIT_OR);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Bit_Xor() throws ParseException {/*@bgen(jjtree) Bit_Xor */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_XOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(BIT_XOR);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Left_Shift() throws ParseException {/*@bgen(jjtree) Left_Shift */
  SimpleNode jjtn000 = new SimpleNode(JJTLEFT_SHIFT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LEFT_SHIFT);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Right_Shift() throws ParseException {/*@bgen(jjtree) Right_Shift */
  SimpleNode jjtn000 = new SimpleNode(JJTRIGHT_SHIFT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(RIGHT_SHIFT);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void R_Paren() throws ParseException {/*@bgen(jjtree) R_Paren */
  SimpleNode jjtn000 = new SimpleNode(JJTR_PAREN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(R_PAREN);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void L_Paren() throws ParseException {/*@bgen(jjtree) L_Paren */
  SimpleNode jjtn000 = new SimpleNode(JJTL_PAREN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(L_PAREN);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Plus() throws ParseException {/*@bgen(jjtree) Plus */
  SimpleNode jjtn000 = new SimpleNode(JJTPLUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(PLUS);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Plus_Plus() throws ParseException {/*@bgen(jjtree) Plus_Plus */
  SimpleNode jjtn000 = new SimpleNode(JJTPLUS_PLUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(PLUS_PLUS);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Minus() throws ParseException {/*@bgen(jjtree) Minus */
  SimpleNode jjtn000 = new SimpleNode(JJTMINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MINUS);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Minus_Minus() throws ParseException {/*@bgen(jjtree) Minus_Minus */
  SimpleNode jjtn000 = new SimpleNode(JJTMINUS_MINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MINUS_MINUS);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Star() throws ParseException {/*@bgen(jjtree) Star */
  SimpleNode jjtn000 = new SimpleNode(JJTSTAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(STAR);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Mod() throws ParseException {/*@bgen(jjtree) Mod */
  SimpleNode jjtn000 = new SimpleNode(JJTMOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MOD);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Divide() throws ParseException {/*@bgen(jjtree) Divide */
  SimpleNode jjtn000 = new SimpleNode(JJTDIVIDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DIVIDE);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Equals() throws ParseException {/*@bgen(jjtree) Equals */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(EQUALS);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Less_Than() throws ParseException {/*@bgen(jjtree) Less_Than */
  SimpleNode jjtn000 = new SimpleNode(JJTLESS_THAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LESS_THAN);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Greater_Than() throws ParseException {/*@bgen(jjtree) Greater_Than */
  SimpleNode jjtn000 = new SimpleNode(JJTGREATER_THAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(GREATER_THAN);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Equals_Equals() throws ParseException {/*@bgen(jjtree) Equals_Equals */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUALS_EQUALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(EQUALS_EQUALS);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static final public void Not_Equals() throws ParseException {/*@bgen(jjtree) Not_Equals */
  SimpleNode jjtn000 = new SimpleNode(JJTNOT_EQUALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(NOT_EQUALS);
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  static String handleError(String message) throws ParseException {/*@bgen(jjtree) handleError */
     SimpleNode jjtn000 = new SimpleNode(JJTHANDLEERROR);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     try {ParseException ex = generateParseException();
        Token token = ex.currentToken;
        System.out.println(ex.getMessage() + "\u005cn" + message);

        do {
                token = getNextToken();
        } while (token.kind != SEMI_COLON);

        jjtree.popNode();
        return token.image;/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
  }

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  static private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  static private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  static private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  static private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  static private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  static private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  static private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  static private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  static private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  static private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  static private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  static private boolean jj_2_24(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  static private boolean jj_2_25(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  static private boolean jj_2_26(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  static private boolean jj_2_27(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  static private boolean jj_2_28(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  static private boolean jj_2_29(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  static private boolean jj_2_30(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  static private boolean jj_2_31(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  static private boolean jj_2_32(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  static private boolean jj_2_33(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  static private boolean jj_2_34(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  static private boolean jj_2_35(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  static private boolean jj_2_36(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  static private boolean jj_2_37(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  static private boolean jj_2_38(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  static private boolean jj_2_39(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  static private boolean jj_2_40(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  static private boolean jj_2_41(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  static private boolean jj_2_42(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  static private boolean jj_2_43(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  static private boolean jj_2_44(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  static private boolean jj_2_45(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  static private boolean jj_2_46(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  static private boolean jj_2_47(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  static private boolean jj_2_48(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  static private boolean jj_2_49(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  static private boolean jj_2_50(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  static private boolean jj_2_51(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  static private boolean jj_2_52(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  static private boolean jj_2_53(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  static private boolean jj_2_54(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  static private boolean jj_2_55(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  static private boolean jj_2_56(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  static private boolean jj_2_57(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  static private boolean jj_2_58(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  static private boolean jj_2_59(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  static private boolean jj_2_60(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  static private boolean jj_2_61(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  static private boolean jj_2_62(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  static private boolean jj_2_63(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  static private boolean jj_2_64(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  static private boolean jj_2_65(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  static private boolean jj_2_66(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  static private boolean jj_2_67(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  static private boolean jj_2_68(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  static private boolean jj_2_69(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  static private boolean jj_2_70(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  static private boolean jj_2_71(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  static private boolean jj_2_72(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  static private boolean jj_2_73(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  static private boolean jj_2_74(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  static private boolean jj_2_75(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  static private boolean jj_2_76(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  static private boolean jj_2_77(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_77(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  static private boolean jj_2_78(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_78(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(77, xla); }
  }

  static private boolean jj_2_79(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_79(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(78, xla); }
  }

  static private boolean jj_2_80(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_80(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(79, xla); }
  }

  static private boolean jj_2_81(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_81(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(80, xla); }
  }

  static private boolean jj_2_82(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_82(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(81, xla); }
  }

  static private boolean jj_2_83(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_83(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(82, xla); }
  }

  static private boolean jj_2_84(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_84(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(83, xla); }
  }

  static private boolean jj_2_85(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_85(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(84, xla); }
  }

  static private boolean jj_2_86(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_86(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(85, xla); }
  }

  static private boolean jj_2_87(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_87(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(86, xla); }
  }

  static private boolean jj_2_88(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_88(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(87, xla); }
  }

  static private boolean jj_2_89(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_89(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(88, xla); }
  }

  static private boolean jj_2_90(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_90(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(89, xla); }
  }

  static private boolean jj_2_91(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_91(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(90, xla); }
  }

  static private boolean jj_2_92(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_92(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(91, xla); }
  }

  static private boolean jj_2_93(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_93(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(92, xla); }
  }

  static private boolean jj_2_94(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_94(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(93, xla); }
  }

  static private boolean jj_2_95(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_95(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(94, xla); }
  }

  static private boolean jj_2_96(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_96(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(95, xla); }
  }

  static private boolean jj_2_97(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_97(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(96, xla); }
  }

  static private boolean jj_2_98(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_98(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(97, xla); }
  }

  static private boolean jj_2_99(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_99(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(98, xla); }
  }

  static private boolean jj_2_100(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_100(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(99, xla); }
  }

  static private boolean jj_2_101(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_101(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(100, xla); }
  }

  static private boolean jj_2_102(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_102(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(101, xla); }
  }

  static private boolean jj_2_103(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_103(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(102, xla); }
  }

  static private boolean jj_2_104(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_104(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(103, xla); }
  }

  static private boolean jj_2_105(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_105(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(104, xla); }
  }

  static private boolean jj_2_106(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_106(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(105, xla); }
  }

  static private boolean jj_2_107(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_107(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(106, xla); }
  }

  static private boolean jj_2_108(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_108(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(107, xla); }
  }

  static private boolean jj_3_53()
 {
    if (jj_scan_token(71)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_52()
 {
    if (jj_scan_token(70)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_51()
 {
    if (jj_scan_token(69)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_50()
 {
    if (jj_scan_token(68)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_49()
 {
    if (jj_scan_token(67)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_59()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_48()) {
    jj_scanpos = xsp;
    if (jj_3_49()) {
    jj_scanpos = xsp;
    if (jj_3_50()) {
    jj_scanpos = xsp;
    if (jj_3_51()) {
    jj_scanpos = xsp;
    if (jj_3_52()) {
    jj_scanpos = xsp;
    if (jj_3_53()) {
    jj_scanpos = xsp;
    if (jj_3_54()) {
    jj_scanpos = xsp;
    if (jj_3_55()) {
    jj_scanpos = xsp;
    if (jj_3_56()) {
    jj_scanpos = xsp;
    if (jj_3_57()) {
    jj_scanpos = xsp;
    if (jj_3_58()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_48()
 {
    if (jj_scan_token(66)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_36()
 {
    if (jj_3R_29()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_106()
 {
    if (jj_3R_52()) return true;
    return false;
  }

  static private boolean jj_3_35()
 {
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_47()
 {
    if (jj_scan_token(60)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_105()
 {
    if (jj_3R_51()) return true;
    return false;
  }

  static private boolean jj_3_31()
 {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_35()) return true;
    return false;
  }

  static private boolean jj_3R_37()
 {
    if (jj_3R_27()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_59()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_34()
 {
    if (jj_3R_29()) return true;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3R_29()
 {
    if (jj_3R_37()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_47()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_33()
 {
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_104()
 {
    if (jj_3R_30()) return true;
    return false;
  }

  static private boolean jj_3R_57()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_104()) {
    jj_scanpos = xsp;
    if (jj_3_105()) {
    jj_scanpos = xsp;
    if (jj_3_106()) {
    jj_scanpos = xsp;
    if (jj_3_107()) {
    jj_scanpos = xsp;
    if (jj_3_108()) return true;
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_38()
 {
    if (jj_3R_29()) return true;
    return false;
  }

  static private boolean jj_3_46()
 {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) jj_scanpos = xsp;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_32()
 {
    if (jj_3R_29()) return true;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_102()
 {
    if (jj_scan_token(60)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_45()
 {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_35()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(L_PAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_41()
 {
    if (jj_3R_36()) return true;
    return false;
  }

  static private boolean jj_3_101()
 {
    if (jj_scan_token(61)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(62)) return true;
    return false;
  }

  static private boolean jj_3_44()
 {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(L_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3_33()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3_35()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3_37()) return true;
    }
    if (jj_3R_35()) return true;
    return false;
  }

  static private boolean jj_3_40()
 {
    if (jj_3R_29()) return true;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_100()
 {
    if (jj_scan_token(L_PAREN)) return true;
    if (jj_3R_50()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_103()
 {
    if (jj_3R_37()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_102()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_43()
 {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(L_PAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    if (jj_3R_35()) return true;
    return false;
  }

  static private boolean jj_3R_50()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_103()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_39()
 {
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3R_35()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_39()) {
    jj_scanpos = xsp;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3_42()) {
    jj_scanpos = xsp;
    if (jj_3_43()) {
    jj_scanpos = xsp;
    if (jj_3_44()) {
    jj_scanpos = xsp;
    if (jj_3_45()) {
    jj_scanpos = xsp;
    if (jj_3_46()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_42()
 {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(L_PAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    if (jj_3R_35()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_31()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_99()
 {
    if (jj_scan_token(MINUS_MINUS)) return true;
    return false;
  }

  static private boolean jj_3_97()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_98()) {
    jj_scanpos = xsp;
    if (jj_3_99()) {
    jj_scanpos = xsp;
    if (jj_3_100()) {
    jj_scanpos = xsp;
    if (jj_3_101()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3_98()
 {
    if (jj_scan_token(PLUS_PLUS)) return true;
    return false;
  }

  static private boolean jj_3_30()
 {
    if (jj_3R_35()) return true;
    return false;
  }

  static private boolean jj_3_29()
 {
    if (jj_3R_34()) return true;
    return false;
  }

  static private boolean jj_3R_36()
 {
    if (jj_scan_token(64)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_30()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(65)) return true;
    return false;
  }

  static private boolean jj_3R_49()
 {
    if (jj_3R_57()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_97()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_95()
 {
    if (jj_scan_token(SIZEOF)) return true;
    if (jj_scan_token(L_PAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_96()
 {
    if (jj_scan_token(L_PAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_27()
 {
    if (jj_3R_29()) return true;
    return false;
  }

  static private boolean jj_3_94()
 {
    if (jj_scan_token(SIZEOF)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_28()
 {
    if (jj_scan_token(61)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_27()) jj_scanpos = xsp;
    if (jj_scan_token(62)) return true;
    return false;
  }

  static private boolean jj_3_26()
 {
    if (jj_3R_32()) return true;
    return false;
  }

  static private boolean jj_3_93()
 {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3R_33()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_26()) jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    xsp = jj_scanpos;
    if (jj_3_28()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_92()
 {
    if (jj_scan_token(STAR)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_91()
 {
    if (jj_scan_token(BIT_NOT)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_90()
 {
    if (jj_scan_token(BOOLEAN_NOT)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_89()
 {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_88()
 {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_87()
 {
    if (jj_scan_token(MINUS_MINUS)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_81()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_82()) {
    jj_scanpos = xsp;
    if (jj_3_83()) {
    jj_scanpos = xsp;
    if (jj_3_84()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_82()
 {
    if (jj_scan_token(STAR)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_86()
 {
    if (jj_scan_token(PLUS_PLUS)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_85()
 {
    if (jj_3R_49()) return true;
    return false;
  }

  static private boolean jj_3R_48()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_85()) {
    jj_scanpos = xsp;
    if (jj_3_86()) {
    jj_scanpos = xsp;
    if (jj_3_87()) {
    jj_scanpos = xsp;
    if (jj_3_88()) {
    jj_scanpos = xsp;
    if (jj_3_89()) {
    jj_scanpos = xsp;
    if (jj_3_90()) {
    jj_scanpos = xsp;
    if (jj_3_91()) {
    jj_scanpos = xsp;
    if (jj_3_92()) {
    jj_scanpos = xsp;
    if (jj_3_93()) {
    jj_scanpos = xsp;
    if (jj_3_94()) {
    jj_scanpos = xsp;
    if (jj_3_95()) {
    jj_scanpos = xsp;
    if (jj_3_96()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_15()
 {
    if (jj_scan_token(60)) return true;
    if (jj_3R_31()) return true;
    return false;
  }

  static private boolean jj_3_25()
 {
    if (jj_scan_token(60)) return true;
    if (jj_scan_token(63)) return true;
    return false;
  }

  static private boolean jj_3_78()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_79()) {
    jj_scanpos = xsp;
    if (jj_3_80()) return true;
    }
    return false;
  }

  static private boolean jj_3_79()
 {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  static private boolean jj_3_20()
 {
    if (jj_3R_29()) return true;
    return false;
  }

  static private boolean jj_3_24()
 {
    if (jj_3R_33()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_23()
 {
    if (jj_scan_token(60)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  static private boolean jj_3_21()
 {
    if (jj_scan_token(61)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) jj_scanpos = xsp;
    if (jj_scan_token(62)) return true;
    return false;
  }

  static private boolean jj_3_84()
 {
    if (jj_scan_token(MOD)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_83()
 {
    if (jj_scan_token(DIVIDE)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3_80()
 {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  static private boolean jj_3R_47()
 {
    if (jj_3R_48()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_81()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_19()
 {
    if (jj_3R_30()) return true;
    return false;
  }

  static private boolean jj_3_22()
 {
    if (jj_3R_32()) return true;
    return false;
  }

  static private boolean jj_3_75()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_76()) {
    jj_scanpos = xsp;
    if (jj_3_77()) return true;
    }
    return false;
  }

  static private boolean jj_3_76()
 {
    if (jj_scan_token(LEFT_SHIFT)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  static private boolean jj_3R_24()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    if (jj_scan_token(L_PAREN)) return true;
    xsp = jj_scanpos;
    if (jj_3_24()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_25()) jj_scanpos = xsp;
    if (jj_scan_token(R_PAREN)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  static private boolean jj_3_16()
 {
    if (jj_3R_31()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_15()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_77()
 {
    if (jj_scan_token(RIGHT_SHIFT)) return true;
    if (jj_3R_46()) return true;
    return false;
  }

  static private boolean jj_3R_46()
 {
    if (jj_3R_47()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_78()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_17()
 {
    if (jj_3R_30()) return true;
    return false;
  }

  static private boolean jj_3_72()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_73()) {
    jj_scanpos = xsp;
    if (jj_3_74()) return true;
    }
    return false;
  }

  static private boolean jj_3_73()
 {
    if (jj_scan_token(LESS_THAN)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  static private boolean jj_3_18()
 {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_31()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3_19()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_21()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_74()
 {
    if (jj_scan_token(79)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  static private boolean jj_3R_45()
 {
    if (jj_3R_46()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_75()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_70()
 {
    if (jj_scan_token(GREATER_THAN)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  static private boolean jj_3_69()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_70()) {
    jj_scanpos = xsp;
    if (jj_3_71()) return true;
    }
    return false;
  }

  static private boolean jj_3R_23()
 {
    if (jj_3R_32()) return true;
    if (jj_3R_30()) return true;
    if (jj_scan_token(L_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) jj_scanpos = xsp;
    if (jj_scan_token(R_PAREN)) return true;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_14()
 {
    if (jj_scan_token(STAR)) return true;
    if (jj_3R_28()) return true;
    return false;
  }

  static private boolean jj_3_13()
 {
    if (jj_3R_30()) return true;
    return false;
  }

  static private boolean jj_3_10()
 {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  static private boolean jj_3R_28()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3_14()) return true;
    }
    return false;
  }

  static private boolean jj_3_71()
 {
    if (jj_scan_token(78)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  static private boolean jj_3R_44()
 {
    if (jj_3R_45()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_72()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_67()
 {
    if (jj_scan_token(EQUALS_EQUALS)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  static private boolean jj_3_66()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_67()) {
    jj_scanpos = xsp;
    if (jj_3_68()) return true;
    }
    return false;
  }

  static private boolean jj_3_12()
 {
    if (jj_3R_28()) return true;
    return false;
  }

  static private boolean jj_3R_43()
 {
    if (jj_3R_44()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_69()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_65()
 {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  static private boolean jj_3R_52()
 {
    if (jj_scan_token(STRING_LIT)) return true;
    return false;
  }

  static private boolean jj_3_11()
 {
    if (jj_3R_28()) return true;
    if (jj_scan_token(61)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(62)) return true;
    return false;
  }

  static private boolean jj_3R_55()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3_12()) return true;
    }
    return false;
  }

  static private boolean jj_3_68()
 {
    if (jj_scan_token(NOT_EQUALS)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  static private boolean jj_3R_51()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  static private boolean jj_3R_42()
 {
    if (jj_3R_43()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_66()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_64()
 {
    if (jj_scan_token(BIT_XOR)) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  static private boolean jj_3R_53()
 {
    if (jj_scan_token(CHARACTER_CONST)) return true;
    return false;
  }

  static private boolean jj_3R_26()
 {
    if (jj_3R_55()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_30()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_41()
 {
    if (jj_3R_42()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_65()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_63()
 {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_40()) return true;
    return false;
  }

  static private boolean jj_3_108()
 {
    if (jj_scan_token(L_PAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(R_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_9()
 {
    if (jj_scan_token(60)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  static private boolean jj_3R_40()
 {
    if (jj_3R_41()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_64()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_54()
 {
    if (jj_3R_26()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_62()
 {
    if (jj_scan_token(BOOLEAN_AND)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  static private boolean jj_3_6()
 {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  static private boolean jj_3R_34()
 {
    if (jj_3R_25()) return true;
    if (jj_3R_54()) return true;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3R_39()
 {
    if (jj_3R_40()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_63()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_7()
 {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  static private boolean jj_3_61()
 {
    if (jj_scan_token(BOOLEAN_OR)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  static private boolean jj_3_8()
 {
    if (jj_3R_25()) return true;
    return false;
  }

  static private boolean jj_3R_22()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    if (jj_scan_token(SEMI_COLON)) return true;
    return false;
  }

  static private boolean jj_3_107()
 {
    if (jj_3R_53()) return true;
    return false;
  }

  static private boolean jj_3R_38()
 {
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_62()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_32()
 {
    if (jj_3R_25()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_60()
 {
    if (jj_scan_token(76)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(77)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  static private boolean jj_3R_56()
 {
    if (jj_3R_38()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_61()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_4()
 {
    if (jj_3R_24()) return true;
    return false;
  }

  static private boolean jj_3_3()
 {
    if (jj_3R_23()) return true;
    return false;
  }

  static private boolean jj_3_5()
 {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  static private boolean jj_3R_25()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    }
    return false;
  }

  static private boolean jj_3_58()
 {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_57()
 {
    if (jj_scan_token(75)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3R_27()
 {
    if (jj_3R_56()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_60()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_56()
 {
    if (jj_scan_token(74)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_1()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3_4()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_2()
 {
    if (jj_3R_22()) return true;
    return false;
  }

  static private boolean jj_3_55()
 {
    if (jj_scan_token(73)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_3_37()
 {
    if (jj_scan_token(R_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_54()
 {
    if (jj_scan_token(72)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public SmallCCTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[0];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[108];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SmallCC(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SmallCC(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SmallCCTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SmallCC(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SmallCCTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SmallCC(SmallCCTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SmallCCTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[80];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 0; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 80; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 108; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
            case 76: jj_3_77(); break;
            case 77: jj_3_78(); break;
            case 78: jj_3_79(); break;
            case 79: jj_3_80(); break;
            case 80: jj_3_81(); break;
            case 81: jj_3_82(); break;
            case 82: jj_3_83(); break;
            case 83: jj_3_84(); break;
            case 84: jj_3_85(); break;
            case 85: jj_3_86(); break;
            case 86: jj_3_87(); break;
            case 87: jj_3_88(); break;
            case 88: jj_3_89(); break;
            case 89: jj_3_90(); break;
            case 90: jj_3_91(); break;
            case 91: jj_3_92(); break;
            case 92: jj_3_93(); break;
            case 93: jj_3_94(); break;
            case 94: jj_3_95(); break;
            case 95: jj_3_96(); break;
            case 96: jj_3_97(); break;
            case 97: jj_3_98(); break;
            case 98: jj_3_99(); break;
            case 99: jj_3_100(); break;
            case 100: jj_3_101(); break;
            case 101: jj_3_102(); break;
            case 102: jj_3_103(); break;
            case 103: jj_3_104(); break;
            case 104: jj_3_105(); break;
            case 105: jj_3_106(); break;
            case 106: jj_3_107(); break;
            case 107: jj_3_108(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
