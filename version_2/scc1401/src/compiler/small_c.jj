/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. small_c.jj */
/*@egen*//*
	small_c.jjt

    Small-C compiler - SJSU
	March-16-2015

	By Sean Papay, Matt Pleva, Luca Severini
*/

options
{
	DEBUG_PARSER = false;
	LOOKAHEAD = 99999;
  	// NODE_CLASS = "MyNode";
}

PARSER_BEGIN(SmallCC)

package compiler;

import java.util.*;
import retree.statement.*;
import retree.expression.*;
import retree.exceptions.*;
import retree.program.*;
import retree.type.*;
import retree.symtab.*;
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Map.Entry;
import static retree.RetreeUtils.*;

public class SmallCC/*@bgen(jjtree)*/implements SmallCCTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTSmallCCState jjtree = new JJTSmallCCState();

/*@egen*/
	// protected static JJTSmallCCState jjtree = new JJTSmallCCState(); // used during tree build
	private static List<Initializer> stringInits;
	private static int stringLiteralIdx;
	public static SymbolTableStack variableTable;
	public static HashMap<String, ConstantExpression> functionTable;
	// when a function is defined, we stage it here.  Only when it is called do we add it to our program.
	private static HashMap<ConstantExpression, FunctionDefinition> pendingFunctionDefinitions;
	private static HashSet<FunctionDefinition> includedFunctions;
	public static HashMap<String, String> labelTable;
	public static List<Pair<String, String>> arrMemberLabelTable;

	public static String autocoderFile = null;
	public static String compilationTime = null;

	public static boolean inAsmFunc = false;

  	public static int stackMem = 400;
  	public static int dataMem = 2000;
  	public static int codeMem = 0;					// if 0 then put the code immediately after the data
	public static boolean reuseStringLiterals = false;
	
  	private static int labelNumber = 0;
  	public static int nextLabelNumber()
  	{
		return labelNumber++;
	}

	public static String getLabelForVariable(String var)
	{
		if(labelTable.containsKey(var))
		{
			String label = labelTable.get(var);
			return label;
		}
		else
		{
			String label = label(nextLabelNumber());
			labelTable.put(var, label);
			return label;
		}
	}

	public static String getVariableLabelValue(String label)
	{
		for (Entry<String, String> entry : labelTable.entrySet()) 
		{
			if (label.equals(entry.getValue()))
			{
				return entry.getKey();
			}
		}

		return null;
	}

	public static String getLabelForArrayMember(String var)
	{
		String label = label(nextLabelNumber());

		@SuppressWarnings("unchecked")
		Pair<String, String> p = new Pair(label, var);
		arrMemberLabelTable.add(p);

		return label;
	}

	public static String getFunctionNameFromExpression(ConstantExpression c)
	{
		for (Map.Entry<String,ConstantExpression> entry : functionTable.entrySet())
		{
			if (entry.getValue() == c)
			{
				return entry.getKey();
			}
		}
		
		return "UNNAMED FUNCTION";
	}

	public static void main(String args[]) throws Exception
	{
        if(args.length == 0)
        {
            System.out.println("No input file");
			System.exit(1);
        }
        else
        {
            System.exit(compile(args[0], null, 0, 0, 0));
        }
	}

	public static int compile(String inputFile, String outputFile, int stackLoc, int codeLoc, int dataLoc) throws Exception
	{
    	SimpleDateFormat sdf = new SimpleDateFormat("d-MMM-y h:mm:ss a");  // 24 hours -> "d-MMM-y hh:mm:ss";
		compilationTime = sdf.format(Calendar.getInstance().getTime());

		if(stackLoc > 0 && stackLoc < 16000)
		{
			stackMem = stackLoc;
		}

		if(codeLoc > 0 && codeLoc < 16000)
		{
			codeMem = codeLoc;
		}

		if(dataLoc > 0 && dataLoc < 16000)
		{
			dataMem = dataLoc;
		}

		if(outputFile.length() > 0)
		{
			File f = new File(outputFile);
			autocoderFile = f.getName();
		}
		else
		{
			autocoderFile = "";
		}

		System.out.println("Stack: " + stackMem);
		System.out.println("Code: " + codeMem);
		System.out.println("Data: " + dataMem);
		System.out.println("Reuse String Constants: " + (reuseStringLiterals ? "YES" : "NO"));

		File inFile = new File(inputFile);
		Reader sr = new FileReader(inFile);

		stringInits = new ArrayList<Initializer>();
		stringLiteralIdx = 0;
		functionTable = new HashMap<String, ConstantExpression>();
		variableTable = new SymbolTableStack(dataMem);
		pendingFunctionDefinitions = new HashMap<ConstantExpression, FunctionDefinition>();
		includedFunctions = new HashSet<FunctionDefinition>();
		labelTable = new HashMap<String, String>();
		arrMemberLabelTable = new ArrayList<Pair<String, String>>();

		ArrayList<Type> tmp = new ArrayList<Type>();
		tmp.add(new PointerType(Type.charType));
		tmp.add(null);

		int asmFuncNumber = nextLabelNumber();
		functionTable.put("asm", new ConstantExpression(new FunctionType(Type.intType, tmp, true), asmFuncNumber));

		SmallCC parser = new SmallCC(sr);
		try
		{
			Program program = parser.program();
			if(program != null)
			{
				for (Initializer i : stringInits)
				{
					program.addInitializer(i);
				}

				if (errorFree)
				{
					String code = program.generateCode();

					if(outputFile != null)
					{
						File outFile = new File(outputFile);
						Writer wr = new FileWriter(outFile);
						wr.write(code);
						wr.close();
					}
					else
					{
						System.out.print(code);
					}
				}
			}
			else
			{
				errorFree = false;
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			errorFree = false;
		}

		// Node rootNode = jjtree.rootNode();
		// printTree((SimpleNode)rootNode);

		return(errorFree ? 0 : 1);
  	}

  	private static boolean errorFree = true;

  	public static void reportError(Exception e, Token t)
	{
		reportError(e.toString(), t);
	}

	public static void reportError(String m, Token t)
	{
		errorFree = false;
		System.out.println("Error on line " + t.beginLine + " column " + t.beginColumn);
		System.out.println(m);
	}

	public static void printTree(SimpleNode node)
	{
		System.out.println("===== AST (parse tree) =====");

		printTree(node, 0);
	}

	public static void printTree(SimpleNode node, int level)
	{
		for(int i = 0; i < level; ++i)
		{
			System.out.print("    ");
		}

		//MyNode n = (MyNode) node;
		//int kind = n.getKind();
		//String name = n.getName();

		String begin = String.format("<%s>", node.toString());
		System.out.println(begin);

		// System.out.println(kind);
		//if(kind == 49 || kind == 50 || kind == 51 || kind == 52 || kind == 15)
		//{
			//for(int i = 0; i < level; ++i)
			//{
			//	System.out.print("    ");
			//}

			// System.out.println("    " + node.value);
		//}

		int numChildren = node.jjtGetNumChildren();
		for(int i = 0; i < numChildren; ++i)
		{
			printTree((SimpleNode) node.jjtGetChild(i), level + 1);
		}

		for(int i = 0; i < level; ++i)
		{
			System.out.print("    ");
		}

		String end = String.format("</%s>", node.toString());
		System.out.println(end);
	}
}

PARSER_END(SmallCC)


SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r\n"
}

TOKEN :
{
    <BREAK : "break">
  | <CASE: "case">
  | <CONTINUE: "continue">
  | <_DEFAULT: "default">
  | <DO: "do">
  | <ELSE: "else">
  | <FOR: "for">
  | <GOTO: "goto">
  | <IF: "if">
  | <INT: "int">
  | <CHAR: "char">
  | <LONG: "long">
  | <RETURN: "return">
  | <SHORT: "short">
  | <SIZEOF: "sizeof">
  | <STATIC: "static">
  | <SWITCH: "switch">
  | <TYPEDEF: "typedef">
  | <UNSIGNED: "unsigned">
  | <WHILE: "while">
  | <SEMI_COLON: ";">
  | <PLUS_PLUS: "++">
  | <MINUS_MINUS: "--">
  | <PLUS: "+">
  | <MINUS: "-">
  | <STAR: "*">
  | <DIVIDE: "/">
  | <MOD: "%">
  | <BIT_AND: "&">
  | <BIT_OR: "|">
  | <BIT_XOR: "^">
  | <BIT_NOT: "~">
  | <BOOLEAN_NOT: "!">
  | <BOOLEAN_AND: "&&">
  | <BOOLEAN_OR: "||">
  | <GREATER_THAN: ">">
  | <LESS_THAN: "<">
  | <LEFT_SHIFT: "<<">
  | <RIGHT_SHIFT: ">>">
  | <EQUALS: "=">
  | <EQUALS_EQUALS: "==">
  | <NOT_EQUALS: "!=">
  | <L_PAREN: "(">
  | <R_PAREN: ")">

  | <IDENTIFIER : (<IDENTIFIER_CHAR>)(<IDENTIFIER_CHAR> | ["0"-"9","_"])*>
  | <NUMBER : (<DIGIT>)+>
  | <STRING_LIT : "\"" (~["\"", "\n", "\\"] | ("\\" ~[]))* "\"">
  | <CHARACTER_CONST  : "\'" (~["\'", "\n", "\\"] | ("\\" ~[]))* "\'">
  | <COMMENT: <LINE_COMMENT> | <MULTI_LINE_COMMENT>>
  | <LINE_COMMENT : "//" (~["\n"])* <NEWLINE> >
  | <MULTI_LINE_COMMENT: "/*" (~["*"] | ("*")* ~["/"])* "*/">
  | <NEWLINE : "\r\n" | "\n" >
  | <#NOT_NEWLINE : ~["\n","\r"]>
  | <#IDENTIFIER_CHAR : ["A"-"Z","a"-"z","_"]>
  | <#DIGIT : ["0"-"9"]>
 }

/** Main production. */

Program program() throws Exception : {/*@bgen(jjtree) program */
        SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Program program = new Program();
	List<Initializer> initList = new ArrayList<Initializer>();
	FunctionDefinition func;
}
{/*@bgen(jjtree) program */
                try {
/*@egen*/
  		(initList = globalVariableDeclaration() {
				//System.out.println(initList.size());
				for (Initializer init : initList) {
					program.addInitializer(init);
				}
			}
				| functionDeclaration() //not supported just yet...
				| func = functionDefinition() {
					pendingFunctionDefinitions.put(func.getDeclaration(), func);
					//program.addFunction(func);
				}
			)*/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
  		{
				ConstantExpression mainDec = functionTable.get("main");
				if (mainDec == null) {
					System.out.println("Missing main function");
					return null;
				}
				if (pendingFunctionDefinitions.containsKey(mainDec)) {
					includedFunctions.add(pendingFunctionDefinitions.remove(mainDec));
				}
				int mainLabelNumber = mainDec.getValue();
				for (FunctionDefinition def : includedFunctions) {
					program.addFunction(def);
				}
				program.setMainLabelNumber(mainLabelNumber);

				return program;
			}/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

Type bareType(): {/*@bgen(jjtree) bareType */
  SimpleNode jjtn000 = new SimpleNode(JJTBARETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) bareType */
  try {
/*@egen*/
  ("char"/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {return Type.charType;} | "int"/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn000, true);
                                            jjtc000 = false;
                                          }
/*@egen*/ {return Type.intType;})/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

Type Type(): {/*@bgen(jjtree) Type */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Type t;
}
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
  	(t = bareType() ("*" {t = new PointerType(t);} )*)/*@bgen(jjtree)*/
                                                           {
                                                             jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
                                                           }
/*@egen*/ {return t;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

List<Initializer> globalVariableDeclaration() : {/*@bgen(jjtree) globalVariableDeclaration */
                SimpleNode jjtn000 = new SimpleNode(JJTGLOBALVARIABLEDECLARATION);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/
		List<Initializer> inits = new ArrayList<Initializer>();
		Type baseType = Type.intType;
}
{/*@bgen(jjtree) globalVariableDeclaration */
        try {
/*@egen*/
	(baseType=bareType() )? inits=variableDeclarationList(baseType, true) ";"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{
    	return inits;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

List<Initializer> localVariableDeclaration() : {/*@bgen(jjtree) localVariableDeclaration */
        SimpleNode jjtn000 = new SimpleNode(JJTLOCALVARIABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	List<Initializer> initializers;
	Type baseType;
}
{/*@bgen(jjtree) localVariableDeclaration */
        try {
/*@egen*/
	baseType = bareType() initializers = variableDeclarationList(baseType, false) ";"/*@bgen(jjtree)*/
                                                                                          {
                                                                                            jjtree.closeNodeScope(jjtn000, true);
                                                                                            jjtc000 = false;
                                                                                          }
/*@egen*/ {
		return initializers;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

List<Initializer> variableDeclarationList(Type baseType, boolean isStatic) : {/*@bgen(jjtree) variableDeclarationList */
        SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATIONLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	List<Initializer> inits = new ArrayList<Initializer>();
	Initializer init;
}
{/*@bgen(jjtree) variableDeclarationList */
        try {
/*@egen*/
	init=variableInitializer(baseType, isStatic) {
		inits.add(init);
	}
	("," init=variableInitializer(baseType, isStatic) {
		inits.add(init);
	})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return inits;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Initializer variableInitializer(Type baseType, boolean isStatic) : {/*@bgen(jjtree) variableInitializer */
        SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEINITIALIZER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Initializer init = null;
	VariableExpression variable;
	Expression value = null;
	Token t = null;
}
{/*@bgen(jjtree) variableInitializer */
        try {
/*@egen*/
	                                                               //ternaryExpression, since we can't have a comma-separated or assignment expression
	variable = suffixedVariable(baseType, isStatic) ("=" {t=token;} value=ternaryExpression())?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		try {
			return new Initializer(variable, value, false);
		} catch(Exception e) {
			reportError(e, t);
			return new Initializer(variable, (Expression)null, false);
		}
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//here is where we add it to our SymbolTable, since we know
//the full type
VariableExpression suffixedVariable(Type baseType, boolean isStatic) : {/*@bgen(jjtree) suffixedVariable */
        SimpleNode jjtn000 = new SimpleNode(JJTSUFFIXEDVARIABLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Pair<Type,String> pair;
	Expression arraySize = null;
	int size = -1;
	Type type;
	Expression variable;
}
{/*@bgen(jjtree) suffixedVariable */
        try {
/*@egen*/
	(pair=PrefixedVariable(baseType) "[" (arraySize = expression()) "]" {
		arraySize = arraySize.collapse();
		if (!(arraySize instanceof ConstantExpression)) {
			System.out.println("Array size is not a constant!");
			throw new NonConstantExpressionException(arraySize);
		}
		size = ((ConstantExpression) arraySize).getValue();
		type = new ArrayType(size, pair.a);
	}
	/* we don't currently support non-sized arrays
	| PrefixedVariable() "[" "]" */
	| pair=PrefixedVariable(baseType) {
		type = pair.a;
	})/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if (isStatic) {
			return SmallCC.variableTable.addStatic(pair.b, type);
		} else {
			return SmallCC.variableTable.add(pair.b,type, false);
		}
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Pair<Type,String> PrefixedVariable(Type baseType) : {/*@bgen(jjtree) PrefixedVariable */
        SimpleNode jjtn000 = new SimpleNode(JJTPREFIXEDVARIABLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Pair<Type,String> pair = new Pair<Type,String>();
	pair.a = baseType;
}
{/*@bgen(jjtree) PrefixedVariable */
        try {
/*@egen*/
	(pair.b=Identifier()
	| "*" pair=PrefixedVariable(new PointerType(baseType)))/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return pair;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void functionDeclaration() : {/*@bgen(jjtree) functionDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) functionDeclaration */
    try {
/*@egen*/
    Type() Identifier() ("(" (FunctionDeclarationParameter() ("," FunctionDeclarationParameter())*)? ")")  ";"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{
		//todo - add this to the symbol table
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionDeclarationParameter(): {/*@bgen(jjtree) FunctionDeclarationParameter */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDECLARATIONPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionDeclarationParameter */
    try {
/*@egen*/
    (Type() (Identifier())? | Identifier()) ("[" (expression())? "]")?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

FunctionDefinition functionDefinition() : {/*@bgen(jjtree) functionDefinition */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDEFINITION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Type retType = Type.intType;
	List<VariableExpression> parameters = new ArrayList<VariableExpression>();
	VariableExpression param;
	FunctionType type;
	String name;
	BlockStatement block;
	variableTable.push();

	try {
		//this is the function's return address.
		//stored under an empty identifier, so no variable can collide with it
		//the value will be assigned automatically.
		variableTable.add("", new PointerType(Type.charType), false);
	} catch(Exception e) {
		reportError("we should never be here 1", token);
	}
}
{/*@bgen(jjtree) functionDefinition */
    try {
/*@egen*/

    (retType=Type())? name=Identifier(){if(name.equals("asm")){inAsmFunc = true;}else{inAsmFunc = false;}}

		(("(" (param=functionDefinitionParameter(parameters.size()) {
			parameters.add(param);
		} ("," param=functionDefinitionParameter(parameters.size()) {
			parameters.add(param);
		})*)? ("," "..." {parameters.add(null);})? ")" ) ) {
			List<Type> paramTypes = new ArrayList<Type>();
			boolean variadic = false;
			for (VariableExpression p : parameters) {
				if (p == null) {
					variadic = true;
					paramTypes.add(null);
					break;
				}
				paramTypes.add(p.getType());
			}
			if (!variadic) {
				//we're calling the location of the return value "return"
				variableTable.add("return", retType, true);
			}

			type = new FunctionType(retType, paramTypes, variadic);
			ConstantExpression dec = functionTable.get(name);
			if (dec != null) {
				if (! dec.getType().equals(type)) {
					throw new Error("Type mismatch: function " + name +
						"was previously declared as type " + dec.getType());
				}
			} else {
				dec = new ConstantExpression(type, nextLabelNumber());
				functionTable.put(name, dec);
			}
		}
				//we provide no return label - this is a top-level block.
        block = blockStatement(true, null)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			variableTable.pop();
			return new FunctionDefinition(dec, block);
		}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

VariableExpression functionDefinitionParameter(int paramNum): {/*@bgen(jjtree) functionDefinitionParameter */
        SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONDEFINITIONPARAMETER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Type type = Type.intType;
	String name;
}
{/*@bgen(jjtree) functionDefinitionParameter */
        try {
/*@egen*/
	(type=Type())? name=Identifier()
	("[" (expression())? "]" {

		//in function parameters, array types are literally just pointer types.
		type = new PointerType(type);
	})?/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {
		if (variableTable.searchTop(name) != null) {
			throw new Error("Redefinition of variable " + name);
		}
		return variableTable.add(name, type, true);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

BlockStatement blockStatement(boolean isFunction, String returnLabel) : {/*@bgen(jjtree) blockStatement */
        SimpleNode jjtn000 = new SimpleNode(JJTBLOCKSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	List<Initializer> initializers = new ArrayList<Initializer>();
	List<Statement> statements = new ArrayList<Statement>();
	List<Initializer> initList;
	String newReturnLabel = label(nextLabelNumber());
	Statement s;
	if (isFunction) {
		try {
			initializers.add(new Initializer(variableTable.searchStack(""), (Expression) null, false));
		} catch (Exception e) {
			reportError("We should never be here 0", token);
		}
	}
}{/*@bgen(jjtree) blockStatement */
        try {
/*@egen*/
	{
		//functions have already pushed, and will pop after
		if (!isFunction) variableTable.push();
	}
	"{" (initList=localVariableDeclaration() {
		for (Initializer init : initList) {
			initializers.add(init);
		}
	})* (s = statement(newReturnLabel) {
		statements.add(s);
	})* "}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		//System.out.println(variableTable.peek().getStackOffset());
		BlockStatement bs = new BlockStatement(initializers, statements, variableTable.peek().getLocalSize(), newReturnLabel, returnLabel);
		if (!isFunction) {
			variableTable.pop();
		}
		return bs;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Statement statement(String returnLabel)  : {/*@bgen(jjtree) statement */
        SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Statement stat, stat2 = null;
	Expression exp=null, exp2=null, exp3=null;
}
{/*@bgen(jjtree) statement */
                try {
/*@egen*/
		";"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {
			return new EmptyStatement();
		}
		| exp=expression() ";"/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/ {
			return new ExpressionStatement(exp);
		}
		| stat = blockStatement(false, returnLabel)/*@bgen(jjtree)*/
                                                            {
                                                              jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
                                                            }
/*@egen*/ {
			return stat;
		}
    | "if" "(" exp=expression() ")" stat=statement(returnLabel) ("else" stat2=statement(returnLabel))?/*@bgen(jjtree)*/
                                                                                                        {
                                                                                                          jjtree.closeNodeScope(jjtn000, true);
                                                                                                          jjtc000 = false;
                                                                                                        }
/*@egen*/  {
			return new IfStatement(exp, stat, stat2);
		}
    | "while" "(" exp=expression() ")" stat=statement(returnLabel)/*@bgen(jjtree)*/
                                                                   {
                                                                     jjtree.closeNodeScope(jjtn000, true);
                                                                     jjtc000 = false;
                                                                   }
/*@egen*/ {
			return new WhileStatement(exp, stat);
		}
    | "for" "(" (exp=expression()";"| ";" ) (exp2=expression() ";" | ";" ) (exp3=expression() ")" | ")" ) stat=statement(returnLabel)/*@bgen(jjtree)*/
                                                                                                                                      {
                                                                                                                                        jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                        jjtc000 = false;
                                                                                                                                      }
/*@egen*/ {
			return new ForStatement(exp, exp2, exp3, stat);
		}
    | "do" stat=statement(returnLabel) "while" "(" exp=expression() ")" ";"/*@bgen(jjtree)*/
                                                                            {
                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
                                                                            }
/*@egen*/ {
			return new DoWhileStatement(exp, stat);
		}
    /* There is an issue here, the block statement in the switch statement isn't taking on any children.  You might have to
     * make another production rule for a switch statement body that looks like a block statement with cases. */
    //TODO| "switch" "(" expression() ")" CaseBlock()
    //TODO| "break" ";"
    //TODO| "continue" ";"
    | "return" (exp=expression())? ";"/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/ {
			return new ReturnStatement(exp, variableTable.searchStack("return"), returnLabel);

		}/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
    //TODO| Identifier() ":" Statement()
    //TODO| "goto" Identifier() ";"
}
/*
void CaseStatement() : {}
{
	(("case" expression() | "default") ":" (CaseStatement() | statement()))
}

void CaseBlock() : {}
{
	"{" (localVariableDeclaration())* (statement() | CaseStatement()) * "}"
}
*/
/** Left-to-right*/
Expression expression() : {/*@bgen(jjtree) expression */
        SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null;
	Expression r = null;
}
{/*@bgen(jjtree) expression */
    try {
/*@egen*/
    l = assignmentExpression() ("," r = assignmentExpression() {
			l = new CommaExpression(l, r);
		})*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
			return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** Right-to-left */
Expression assignmentExpression() : {/*@bgen(jjtree) assignmentExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
	Token lToken = null;
	try {
		lToken = getToken(1);
	} catch(Exception e) {
		reportError("Unexpected end of file.", token);
	}
}
{/*@bgen(jjtree) assignmentExpression */
    try {
/*@egen*/
    (l = ternaryExpression()
			( "+=" r = assignmentExpression() {
				r = new AddExpression(l, r);
			}
			| "-=" r = assignmentExpression() {
				r = new SubtractExpression(l, r);
			}
			| "*=" r = assignmentExpression() {
				r = new MultiplyExpression(l, r);
			}
			| "/=" r = assignmentExpression() {
				r = new DivideExpression(l, r);
			}
			| "%=" r = assignmentExpression() {
				r = new ModuloExpression(l, r);
			}
			| ">>=" r = assignmentExpression() {
				//r = new RightShiftExpression(l, r);
			}
			| "<<=" r = assignmentExpression() {
				//r = new LeftShiftExpression(l, r);
			}
			| "&=" r = assignmentExpression() {
				//r = new AndExpression(l, r);
			}
			| "^=" r = assignmentExpression() {
				//r = new XorExpression(l, r);
			}
			| "|=" r = assignmentExpression() {
				//r = new OrExpression(l, r);
			}
			| "=" r = assignmentExpression())?
		)/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {
				if (r != null) {
					if (l instanceof LValue)
						try {
							return new AssignmentExpression((LValue)l, r);
						} catch (TypeMismatchException e) {
							reportError(e, lToken);
						}
					else reportError("Left side of assignment must be an lvalue.", lToken);
				}
				return l;
			}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression ternaryExpression() : {/*@bgen(jjtree) ternaryExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTTERNARYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, t = null, f = null;
}
{/*@bgen(jjtree) ternaryExpression */
    try {
/*@egen*/
    (l = orExpression() ("?" t = expression() ":" f = ternaryExpression() )?)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
		if (t != null && f != null)
		{
			try {
				return new TernaryExpression(l,t,f);
			} catch (TypeMismatchException e) {
				reportError(e, token);
				return null;
			}
		}
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** left-to-right*/

Expression orExpression() : {/*@bgen(jjtree) orExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) orExpression */
    try {
/*@egen*/
    l = andExpression() ("||" r = andExpression() {
			l = new OrExpression(l, r);
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression andExpression() : {/*@bgen(jjtree) andExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTANDEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) andExpression */
    try {
/*@egen*/
    l = bitOrExpression() ("&&" r = bitOrExpression() {
			l = new AndExpression(l, r);
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression bitOrExpression() : {/*@bgen(jjtree) bitOrExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) bitOrExpression */
    try {
/*@egen*/
    l = bitXorExpression() ("|" r = bitXorExpression() {
			/*
			l = new BitOrExpression(l, r);
			*/
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression bitXorExpression() : {/*@bgen(jjtree) bitXorExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITXOREXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) bitXorExpression */
    try {
/*@egen*/
    l = bitAndExpression() ("^" r = bitAndExpression() {
			/*
			l = new BitXorExpression(l, r);
			*/
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression bitAndExpression() : {/*@bgen(jjtree) bitAndExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITANDEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) bitAndExpression */
    try {
/*@egen*/
    l = equalityExpression() ("&" r = equalityExpression() {
			/*
			l = new BitAndExpression(l, r);
			*/
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression equalityExpression() : {/*@bgen(jjtree) equalityExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTEQUALITYEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) equalityExpression */
    try {
/*@egen*/
    l = greaterThanExpression() ( "==" r = greaterThanExpression() {
			try {
			l = new EqualExpression(l, r);
			} catch(TypeMismatchException e) {
				reportError(e, token);
			}

		}
    | "!=" r = greaterThanExpression() {
			l = new NotEqualExpression(l, r);
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression greaterThanExpression() : {/*@bgen(jjtree) greaterThanExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTGREATERTHANEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) greaterThanExpression */
    try {
/*@egen*/
    l = lessThanExpression() ( ">" r = lessThanExpression() {
			l = new GreaterThanExpression(l, r);
		}
		| ">=" r = lessThanExpression() {
			l = new GreaterThanOrEqualExpression(l, r);
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression lessThanExpression() : {/*@bgen(jjtree) lessThanExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTLESSTHANEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) lessThanExpression */
    try {
/*@egen*/
    l = bitshiftExpression() ( "<" r = bitshiftExpression() {
			l = new LessThanExpression(l, r);
		}
		| "<=" r = bitshiftExpression() {
			l = new LessThanOrEqualExpression(l, r);
		})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression bitshiftExpression()  : {/*@bgen(jjtree) bitshiftExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTBITSHIFTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) bitshiftExpression */
    try {
/*@egen*/
    l = additiveExpression() ( "<<" r = additiveExpression(){
			/*
			l = new BitshiftExpression(l, r);
			*/
		}
		| ">>" r = additiveExpression(){
			/*
			l = new BitshiftExpression(l, r);
			*/
		} )*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression additiveExpression()  : {/*@bgen(jjtree) additiveExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) additiveExpression */
    try {
/*@egen*/
    l = multiplicativeExpression() ( "+" r = multiplicativeExpression(){
			l = new AddExpression(l, r);
		}
		| "-" r = multiplicativeExpression(){
			l = new SubtractExpression(l, r);
		} )*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression multiplicativeExpression()  : {/*@bgen(jjtree) multiplicativeExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression l = null, r = null;
}
{/*@bgen(jjtree) multiplicativeExpression */
    try {
/*@egen*/
    (l = prefixExpression() ( "*" r = prefixExpression(){
			l = new MultiplyExpression(l, r);
		}
    | "/" r = prefixExpression(){
			l = new DivideExpression(l, r);
		}
    | "%" r = prefixExpression(){
			l = new ModuloExpression(l, r);
	} )*)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return l;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Expression prefixExpression()  : {/*@bgen(jjtree) prefixExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTPREFIXEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression e = null;
	Type t;
}
{/*@bgen(jjtree) prefixExpression */
    try {
/*@egen*/
    // issue on the cast. It breaks if((x&y) == 1) {y++;} because it captures the second "(" and thinks type is next
    // TODO add casting back: "(" Type() ")"
    (e = suffixExpression()
    | "++" e = prefixExpression()	{
			return new PreIncrementExpression((LValue)e);
		}
    | "--" e = prefixExpression()	{
			return new PreDecrementExpression((LValue)e);
		}
    | "+" e = prefixExpression()	{
										// e = new PositiveExpression(e);
									}
    | "-" e = prefixExpression()	{
										e = new NegExpression(e);
									}
    | "!" e = prefixExpression()	{
			e = new NotExpression(e);
		}
    | "~" e = prefixExpression()	{
										// e = new BitNotExpression(e);
									}
    | "*" e = prefixExpression()	{
			return new DereferenceExpression(e);
		}
    | "&" e = prefixExpression()	{
			// &array_name == array_name
			if (! (e instanceof ArrayNameExpression)) {
				return new AddressOfExpression((LValue)e);
			}
		}
    | "sizeof" e = prefixExpression()	{
			return new ConstantExpression(Type.intType, e.getType().sizeof());
		}
		| "sizeof" "(" t=Type() ")" {
			return new ConstantExpression(Type.intType, t.sizeof());
		}
    | "(" t = Type() ")" e = prefixExpression()	{
			return new CastExpression(t,e);
		}
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return e;
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

Expression suffixExpression()  : {/*@bgen(jjtree) suffixExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTSUFFIXEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String s = "";
	Expression e, inside;
	List<Expression> arguments;
}
{/*@bgen(jjtree) suffixExpression */
    try {
/*@egen*/
    (e = AtomicExpression(){if((e.getType() instanceof FunctionType) && ((ConstantExpression)e).getValue() == 0) { e = new AssemblyExpression(); inAsmFunc = true;}else {inAsmFunc = false;}}
			( "++"	{
				try {
					e = new PostIncrementExpression((LValue)e);
				} catch (Exception ex) {
					reportError("Expression " + e + "is not an LValue", token);
				}
			}
			| "--"	{
				try {
					e = new PostDecrementExpression((LValue)e);
				} catch (Exception ex) {
					reportError("Expression " + e + "is not an LValue", token);
				}
			}
			| "(" arguments = expressionList(e) ")" {
				if (!(e instanceof AssemblyExpression)) {
					e = new FunctionCallExpression(e,arguments);
				}
			}
			| "[" inside = expression() "]" {
				e = new SubscriptExpression(e, inside);
			} )*)/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
			{
				return e;
			}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

List<Expression> expressionList(Expression e) : {/*@bgen(jjtree) expressionList */
        SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	List<Expression> list = new ArrayList<Expression>();
	Expression exp;
} {/*@bgen(jjtree) expressionList */
        try {
/*@egen*/
	(exp=assignmentExpression() 
	{
		if ((e instanceof AssemblyExpression))
		{
			((AssemblyExpression)e).addASM(token.image);
		} 
		else 
		{
			list.add(exp);
		}
	}
	("," exp=assignmentExpression() {
		if ((e instanceof AssemblyExpression))
		{
			((AssemblyExpression)e).addASM(token.image);
		} 
		else 
		{
			list.add(exp);
		}
	})*)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{
		return list;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Expression AtomicExpression()  : {/*@bgen(jjtree) AtomicExpression */
        SimpleNode jjtn000 = new SimpleNode(JJTATOMICEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Expression e = null;
	ConstantExpression ce = null;
	String str = "";
}
{/*@bgen(jjtree) AtomicExpression */
   try {
/*@egen*/
   (str = Identifier() {
		VariableExpression var = variableTable.searchStack(str);
		if (var == null)
		{
			ConstantExpression fun = functionTable.get(str);
			if (fun == null) 
			{
				reportError("Did not find: " + str + " anywhere did you forget to declare it?", token);
				return null;
			} 
			else 
			{
				if (pendingFunctionDefinitions.containsKey(fun)) 
				{
					//lazily add our function definition to the program
					includedFunctions.add(pendingFunctionDefinitions.remove(fun));
				}
				return fun;
			}
		} 
		else if (var.getType() instanceof ArrayType) 
		{
			return new ArrayNameExpression(var);
		} 
		else 
		{
			return var;
		}
	}
	
    | str = Number(){
		int val = Integer.parseInt(str);
		ce = new ConstantExpression(Type.intType, val);
		e = ce;
	}
	
    | str = StringLiteral() {

		// Use the string value as identifier if string constants can be reused otherwise define an unique identifier 
		String identif = reuseStringLiterals ? str : "STR_LIT_" + Integer.toString(++stringLiteralIdx);
    	
		VariableExpression ve = variableTable.searchStack(str);
		if (ve != null)
		{
			ArrayNameExpression ane = new ArrayNameExpression(ve);
			return ane;
		} 
		else 
		{
			str = str.substring(1, str.length() - 1);
			
			List<Expression> list = new ArrayList<Expression>();
			List<Expression> rlist = new ArrayList<Expression>();
			
			for(int i = 0; i < str.length(); i++)
			{
				if (str.charAt(i) == '\\')
				{
					if(i < str.length() - 1)
					{
						switch(str.charAt(i+1))
						{
							case 'n':
								list.add(new ConstantExpression(Type.charType, '\n'));
								break;
							case '0':
								list.add(new ConstantExpression(Type.charType, 0));
								break;
						}
						i++;
					}
				} 
				else
				 {
					list.add(new ConstantExpression(Type.charType,("" + str.charAt(i)).toUpperCase().charAt(0)));
				}
			}
			list.add(new ConstantExpression(Type.charType, 0));
			
			for (int i = list.size() - 1; i >= 0; i--)
			{
				rlist.add(list.get(i));
			}
			// need the +1 for the '\0' char
			
			ve = variableTable.addStatic(identif, new ArrayType(rlist.size(), Type.charType));
			
			ArrayNameExpression ane = new ArrayNameExpression(ve);
			if (!inAsmFunc)
			{
				stringInits.add(new Initializer(ve, rlist));
			}
			
			return ane;
		}
		// check symtab for this string
		// if it is Put that in arry name expr and ret that
		// get list of const expr
		// add to static symtab if not there
		// var with arrtype len  = len of list
		// arry name expr wrap the varexpr enter it key token text with quotes
		// type = arr type
		// add to private list initilzer for string
		// end add to program b4 code gen
		// return array name
		//
	}
	
    | str=CharacterConstant() {
			int val = 0;
			//strip the quote characters
			str = str.substring(1, str.length() - 1);
			if (str.charAt(0) == '\\') 
			{
				if (str.length() != 2) 
				{
					//invalid char constant
					return null;
				}
				switch(str.charAt(1)) 
				{
					case 'n':
						val = '\n';
						break;
					case '0':
						val = 0;
						break;
				}
			} 
			else 
			{
				if (str.length() != 1) 
				{
					//invalid char constant.
					return null;
				}
				val = Character.toUpperCase(str.charAt(0));
			}
		ce = new ConstantExpression(Type.charType, val);
		e = ce;
	}
	
    | "(" e=expression() ")")/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return e;
	}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

String Identifier() : {/*@bgen(jjtree) Identifier */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    <IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
		return token.image;
	}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String CharacterConstant() : {/*@bgen(jjtree) CharacterConstant */
  SimpleNode jjtn000 = new SimpleNode(JJTCHARACTERCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CharacterConstant */
    try {
/*@egen*/
    <CHARACTER_CONST>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		//System.out.println("char: " + token.image);
		return token.image;
	}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String Number() : {/*@bgen(jjtree) Number */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Number */
    try {
/*@egen*/
    <NUMBER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return token.image;
	}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String StringLiteral() : {/*@bgen(jjtree) StringLiteral */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StringLiteral */
    try {
/*@egen*/
    <STRING_LIT>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return token.image;
	}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Boolean_Not() : {/*@bgen(jjtree) Boolean_Not */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN_NOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Boolean_Not */
    try {
/*@egen*/
    <BOOLEAN_NOT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Boolean_And() : {/*@bgen(jjtree) Boolean_And */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN_AND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Boolean_And */
    try {
/*@egen*/
    <BOOLEAN_AND>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Boolean_Or() : {/*@bgen(jjtree) Boolean_Or */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEAN_OR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Boolean_Or */
    try {
/*@egen*/
    <BOOLEAN_OR>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bit_Not() : {/*@bgen(jjtree) Bit_Not */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_NOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bit_Not */
    try {
/*@egen*/
    <BIT_NOT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bit_And() : {/*@bgen(jjtree) Bit_And */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_AND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bit_And */
    try {
/*@egen*/
    <BIT_AND>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bit_Or() : {/*@bgen(jjtree) Bit_Or */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_OR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bit_Or */
    try {
/*@egen*/
    <BIT_OR>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bit_Xor() : {/*@bgen(jjtree) Bit_Xor */
  SimpleNode jjtn000 = new SimpleNode(JJTBIT_XOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bit_Xor */
    try {
/*@egen*/
    <BIT_XOR>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Left_Shift() : {/*@bgen(jjtree) Left_Shift */
  SimpleNode jjtn000 = new SimpleNode(JJTLEFT_SHIFT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Left_Shift */
    try {
/*@egen*/
    <LEFT_SHIFT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void Right_Shift() : {/*@bgen(jjtree) Right_Shift */
  SimpleNode jjtn000 = new SimpleNode(JJTRIGHT_SHIFT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Right_Shift */
    try {
/*@egen*/
    <RIGHT_SHIFT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

void R_Paren() : {/*@bgen(jjtree) R_Paren */
  SimpleNode jjtn000 = new SimpleNode(JJTR_PAREN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) R_Paren */
    try {
/*@egen*/
    <R_PAREN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void L_Paren() : {/*@bgen(jjtree) L_Paren */
  SimpleNode jjtn000 = new SimpleNode(JJTL_PAREN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) L_Paren */
    try {
/*@egen*/
    <L_PAREN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Plus() : {/*@bgen(jjtree) Plus */
  SimpleNode jjtn000 = new SimpleNode(JJTPLUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Plus */
    try {
/*@egen*/
    <PLUS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Plus_Plus() : {/*@bgen(jjtree) Plus_Plus */
  SimpleNode jjtn000 = new SimpleNode(JJTPLUS_PLUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Plus_Plus */
    try {
/*@egen*/
    <PLUS_PLUS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Minus() : {/*@bgen(jjtree) Minus */
  SimpleNode jjtn000 = new SimpleNode(JJTMINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Minus */
    try {
/*@egen*/
    <MINUS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Minus_Minus() : {/*@bgen(jjtree) Minus_Minus */
  SimpleNode jjtn000 = new SimpleNode(JJTMINUS_MINUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Minus_Minus */
    try {
/*@egen*/
    <MINUS_MINUS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Star(): {/*@bgen(jjtree) Star */
  SimpleNode jjtn000 = new SimpleNode(JJTSTAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Star */
    try {
/*@egen*/
    <STAR>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

void Mod() : {/*@bgen(jjtree) Mod */
  SimpleNode jjtn000 = new SimpleNode(JJTMOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Mod */
    try {
/*@egen*/
    <MOD>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Divide() : {/*@bgen(jjtree) Divide */
  SimpleNode jjtn000 = new SimpleNode(JJTDIVIDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Divide */
    try {
/*@egen*/
    <DIVIDE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Equals() : {/*@bgen(jjtree) Equals */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Equals */
    try {
/*@egen*/
    <EQUALS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Less_Than() : {/*@bgen(jjtree) Less_Than */
  SimpleNode jjtn000 = new SimpleNode(JJTLESS_THAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Less_Than */
    try {
/*@egen*/
    <LESS_THAN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Greater_Than() : {/*@bgen(jjtree) Greater_Than */
  SimpleNode jjtn000 = new SimpleNode(JJTGREATER_THAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Greater_Than */
    try {
/*@egen*/
    <GREATER_THAN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Equals_Equals()  : {/*@bgen(jjtree) Equals_Equals */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUALS_EQUALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Equals_Equals */
    try {
/*@egen*/
    <EQUALS_EQUALS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Not_Equals() : {/*@bgen(jjtree) Not_Equals */
  SimpleNode jjtn000 = new SimpleNode(JJTNOT_EQUALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Not_Equals */
    try {
/*@egen*/
    <NOT_EQUALS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

JAVACODE
String handleError(String message)
{/*@bgen(jjtree) handleError */
     SimpleNode jjtn000 = new SimpleNode(JJTHANDLEERROR);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     try {
/*@egen*/
	ParseException ex = generateParseException();
	Token token = ex.currentToken;
	System.out.println(ex.getMessage() + "\n" + message);

	do {
		token = getNextToken();
	} while (token.kind != SEMI_COLON);

	jjtree.popNode();
	return token.image;/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}