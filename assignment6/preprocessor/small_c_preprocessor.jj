/*
	small_c_preprocessor.jj

    Assignment #6 - CS153 - SJSU
	November-8-2014

	By Sean Papay, Matt Pleva, Luca Severini
*/

options 
{
}

PARSER_BEGIN(SmallCPP)

import java.io.*;

public class SmallCPP 
{
    public static void main(String[] args) throws Exception
    {
		System.out.println("Small-C Pre-processor");

		File file = new File(args[0]);

		System.out.println("Parsing file " + args[0]);

        Reader sr = new FileReader(file) 
		{
			private int[] lookahead = {-1, -1};
			public int read() throws IOException 
			{
				if (lookahead[0] >= 0) 
				{
					int ch = lookahead[0];
					lookahead[0] = lookahead[1];
					lookahead[1] = -1;
					return ch;
				}

				int ch = super.read();
				// possible line continuation
				if (ch == '\\') 
				{
					lookahead[0] = super.read();

					if (lookahead[0] == '\r')
					{
						lookahead[1] = super.read();
						if (lookahead[1] != '\n') 
						{
							return ch;
						} 
						else
						{
							lookahead[0] = '\n';
						}
					}
					
					if (lookahead[0] == '\n')
					{
						lookahead[0] = lookahead[1] = -1;
						do {
							ch = super.read();
							if (ch < 0) return ch;
						} while(Character.isWhitespace((char) ch));

						return ch;
					}
				} 
				else if (ch == '\r')
				{
					lookahead[0] = super.read();
					if (lookahead[0] == '\n') 
					{
						lookahead[0] = lookahead[1] = -1;
						return '\n';
					}
				}
				
				return ch;
			}

			public int read(char[] cbuf, int offset, int length) throws IOException
			{
				int read = 0;
				while (read < length && offset + read < cbuf.length) 
				{
					int ch = read();
					if (ch < 0) 
					{
						break;
					}

					cbuf[offset + (read++)] = (char)ch;
				}

				if (read == 0 && read < length) 
				{
					return -1;
				}

				return read;
			}
        };

		SmallCPP parser = new SmallCPP(sr);

        try {
            parser.Tokens();
		
			System.out.println("File parsed successfully.");
        }
        catch (ParseException ex) 
		{
            ex.printStackTrace();
		}
    }
}

PARSER_END(SmallCPP)

TOKEN : {
	<STRING: <STRING_LIT_1> | <STRING_LIT_2>>
  |	<COMMENTS: <COMMENT> | <COMMENT_BLOCK>>
  | <RESERVED_WORDS: "#include" | "#define" | "#ifdef" | "#ifndef" | "#else" | "#endif" | "#code" | "#data" | "#stack" | "#undef">
  | <IDENTIFIER: (<IDENTIFIER_CHAR>)(<IDENTIFIER_CHAR> | ["0"-"9"])*>
  | <STRING_LIT_1: "\""(~["\"", "\n"])*"\"">
  | <STRING_LIT_2: "<"(~["\"", "\n"])*">">
  | <ASM_BLOCK: "#asm"(~["*"] | ("*")* ~["/"])* "#endasm">
  | <COMMENT: "//"(~["\"", "\n"])*(<NEWLINE>)>
  | <COMMENT_BLOCK: "/*"(~["*"] | ("*")* ~["/"])* "*/">
  | <WHITESPACE: (" " | "\t" | "\r" | "\n")+>
  | <NEWLINE: "\r\n" | "\n">
  | <#IDENTIFIER_CHAR: ["A"-"Z", "a"-"z"] | <SYMBOLS>>
  | <VALUE: <DIGITS>>
  | <DIGITS: (["0"-"9"])+>
  | <SYMBOLS: "~"|"!"|"@"|"%"|"^"|"&"|"*"|"-"|"+"|"="|"|"|"/"|":"|";"|"?"|"<"|">"|"."|","|"'"|"\""|"("|")"|"["|"]"|"{"|"}"|"\\">
}

SKIP:
{
	< "//" (~["\r", "\n"])* >
}

void Reserved_words(StringBuffer buf) : {}
{
    <RESERVED_WORDS>
    {
        buf.append("Type: Reserved word").append(", Value: ").append(token.image).append("\n");
    }
}

void Identifier(StringBuffer buf) : {}
{
    <IDENTIFIER>
    {
        buf.append("Type: Identifier").append(", Value: ").append(token.image).append("\n");
    }
}

void String(StringBuffer buf) : {}
{
    <STRING>
    {
        buf.append("Type: String").append(", Value: ").append(token.image).append("\n");
    }
}

void asm_block(StringBuffer buf) : {}
{
    <ASM_BLOCK>
    {
        buf.append("Type: AsmBlock").append(", Value: ").append(token.image).append("\n");
    }
}

void Value(StringBuffer buf) : {}
{
    <VALUE>
    {
        buf.append("Type: Number").append(", Value: ").append(token.image).append("\n");
    }
}

void Tokens() : { StringBuffer sb = new StringBuffer(); }
{
    (Reserved_words(sb) | Identifier(sb) | String(sb) | Value(sb) | asm_block(sb) | <WHITESPACE> | <COMMENTS>)* <EOF>
    { System.out.println("Parsed tokens:\n\n" + sb.toString()); }
}
