options {
}

PARSER_BEGIN(SmallCPP)
 import java.io.*;
    public class SmallCPP {
        public static void main(String[] args) throws Exception
        {
						File file = new File(args[0]);
						/*
							line continuations and newline encoding are hard to keep
							track of at tokenization time, so we'll handle them
							directly in the reader
						*/
            Reader sr = new FileReader(file) {
							private int[] lookahead = {-1, -1};
							public int read() throws IOException {
								if (lookahead[0] >= 0) {
									int ch = lookahead[0];
									lookahead[0] = lookahead[1];
									lookahead[1] = -1;
									return ch;
								}
								int ch = super.read();
								//possible line continuation
								if (ch == '\\') {
									lookahead[0] = super.read();

									if (lookahead[0] == '\r') {
										//the user is using windows, what a loser :P
										lookahead[1] = super.read();
										if (lookahead[1] != '\n') {
											//carriage return with no line feed, what's going on?
                                            // maybe we are printing a bold character or an underline
											return ch;
										} else {
											lookahead[0] = '\n';
										}
									}
									if (lookahead[0] == '\n') {
										lookahead[0] = lookahead[1] = -1;
										do {
											ch = super.read();
											if (ch < 0) return ch;
										} while(Character.isWhitespace((char) ch));
										return ch;
									}
								} else if (ch == '\r') {
									lookahead[0] = super.read();
									if (lookahead[0] == '\n') {
										lookahead[0] = lookahead[1] = -1;
										return '\n';
									}
								}
								return ch;
							}

							public int read(char[] cbuf, int offset, int length) throws IOException{
								int read = 0;
								while (read < length && offset + read < cbuf.length) {
									int ch = read();
									if (ch < 0) break;
									cbuf[offset + (read++)] = (char) ch;
								}
								if (read == 0 && read < length) return -1;
								return read;
							}
            };
            SmallCPP parser = new SmallCPP(sr);

            try {
                parser.Tokens();
            }
                catch (ParseException ex) {
                ex.printStackTrace();
            }
        }
    }
PARSER_END(SmallCPP)

SKIP : {
    " "
  | "\t"
}

TOKEN : {
    <RESERVED_WORDS : "break" | "case" | "char" | "continue" | "default"
			| "do" | "else" | "for" | "goto" | "if" | "int" | "long" | "return"
			| "short" | "sizeof" | "static" | "switch" | "typedef" | "unsigned"
			| "while">
  | <IDENTIFIER : (<IDENTIFIER_CHAR>)(<IDENTIFIER_CHAR> | ["0"-"9","_"])*>
  | <NUMBER : (<DIGIT>)+>
  | <STRING_LIT : "\"" (~["\"", "\n", "\\"] | ("\\" ~[]))* "\"">
  | <CHARACTER  : "\'" (~["\'", "\n", "\\"] | ("\\" ~[]))* "\'">
  | <COMMENT: <LINE_COMMENT> | <MULTI_LINE_COMMENT>>
  | <LINE_COMMENT : "//" (~["\n"])* <NEWLINE> >
  | <WHITESPACE : ("\r" | "\n")+>
  | <MULTI_LINE_COMMENT: "/*" (~["*"] | ("*")* ~["/"])* "*/">
  | <NEWLINE : "\r\n" | "\n" >
  | <#NOT_NEWLINE : ~["\n","\r"]>
  | <#IDENTIFIER_CHAR : ["A"-"Z","a"-"z","_"]>
  | <#DIGIT : ["0"-"9"]>
  | <OPS : (<INTEGRAL_OPS> | <BINARY_OPS> | <BOOLEAN_OPS>)>
  | <#INTEGRAL_OPS : ("*" | "/" | "+" | "-" | "%")>
  | <#BINARY_OPS : ("^" | "&" | "~" | "|")>
  | <#BOOLEAN_OPS : ("!" | "==" | ">" | "<" | "<=" | ">=" | "||" | "&&")>
  | <ASSIGNMENT : ("=" | "+=" | "-=" | "<<=" | ">>=" | "%=" | "*=" | "/=" | "^=" | "&=" | "|=" | "~=")>
  | <END_STATEMENT: ";">
  | <SYMBOL : "~"|"!"|"@"|"%"|"^"|"&"|"*"|"-"|"+"|"="|"|"|"/"|":"|";"
		|"?"|"<"|">"|"."|","|"'"|"\""|"("|")"|"["|"]"|"{"|"}"|"<<"
		|">>"|"<="|">="|"+="|"-="|"*="|"/="|"=="|"|="|"%="|"&="|"^="|"||"
		|"&&"|"!="|"<<="|">>=" >
 }

void Reserved_words(StringBuffer buf) : {}
{
    <RESERVED_WORDS>
    {
        buf.append("Type: Reserved word").append(", Value: ").append(token.image).append("\n");
    }
}

void Identifier(StringBuffer buf) : {}
{
    <IDENTIFIER>
    {
        buf.append("Type: Identifier").append(", Value: ").append(token.image).append("\n");
    }
}

void Number(StringBuffer buf) : {}
{
    <NUMBER>
    {
        buf.append("Type: Number").append(", Value: ").append(token.image).append("\n");
    }
}

void Symbol(StringBuffer buf) : {}
{
    <SYMBOL>
    {
        buf.append("Type: Symbol").append(", Value: ").append(token.image).append("\n");
    }
}

void Character(StringBuffer buf) : {}
{
    <CHARACTER>
    {
        buf.append("Type: Character").append(", Value: ").append(token.image).append("\n");
    }
}

void String(StringBuffer buf) : {}
{
    <STRING_LIT>
    {
        buf.append("Type: String").append(", Value: ").append(token.image).append("\n");
    }
}

void Ops(StringBuffer buf) : {}
{
    <OPS>
    {
        buf.append("Type: Operator: ").append(token.image).append("\n");
    }
}

void Term(StringBuffer buf) : {}
{
    (Number(buf) | Identifier(buf))
}

void Expression(StringBuffer buf) : {}
{
    Term(buf) (Ops(buf) Term(buf))*
}

void CompoundExpression(StringBuffer buf) : {}
{
    (Symbol(buf))+ (Expression(buf) | Ops(buf) Term(buf)) (Symbol(buf))*
}

void Assignment(StringBuffer buf) : {}
{
    Identifier(buf) (<ASSIGNMENT> Expression(buf) | ("--" | "++")) <END_STATEMENT>
}

void SimpleControl(StringBuffer buf) : {}
{
    CompoundExpression(buf) <WHITESPACE> (Assignment(buf))* Symbol(buf) <WHITESPACE>
}

void Statement(StringBuffer buf) : {}
{
    (Reserved_words(buf))? (Assignment(buf) | SimpleControl(buf))
}

void Tokens() : {
StringBuffer sb = new StringBuffer();
}
{
    (Statement(sb) | String(sb) | Character(sb) | <WHITESPACE> | <COMMENT>)* <EOF>
    { System.out.println("Parsed tokens\n" + sb.toString()); }
}
