/*
	small_c.jj

    Assignment #7 - CS153 - SJSU
	November-18-2014

	By Sean Papay, Matt Pleva, Luca Severini
*/

options
{
	DEBUG_PARSER=false;// true;
	LOOKAHEAD=99999;
  //NODE_CLASS="MyNode";
}

PARSER_BEGIN(SmallCC)

package compiler;
import java.util.*;
import preprocessor.*;
import retree.*;
import retree.expression.*;
import retree.exceptions.*;
import retree.program.*;
import retree.type.*;
import retree.symtab.*;
import java.io.*;

public class SmallCC
{
	// used during tree build
  public static SymbolTableStack variableTable = new SymbolTableStack();
  
  private static int labelNumber = 0;
  
  public static String nextLabel() {
		//all our generated labels will start with a L
		String label = "L";
		int n = labelNumber++;
		while (label.length() < 6) {
			label += ('A' + n%26);
			n /= 26;
		}
		return label;
	}

  public static void main(String args[]) throws Exception
  {
		compile(args[0]);
  }

  public static void compile(String fileName) throws Exception
  {
    File file = new File(fileName);
    Reader sr = new FileReader(file);

    SmallCC parser = new SmallCC(sr);
    Program program = parser.program();
    System.out.print(program.generateCode());
		//printTree(program);

  }

  public static void printTree(SimpleNode node)
  {
  	System.out.println("===== AST (parse tree) =====");

    printTree(node, 0);
  }

  public static void printTree(SimpleNode node, int level)
  {
    for (int i = 0; i < level; ++i)
    {
    	System.out.print("    ");
    }

	MyNode n = (MyNode)node;
	int kind = n.getKind();
	String name = n.getName();

	String begin = String.format("<%s>", node.toString());
    System.out.println(begin);

    // System.out.println(kind);

	if(kind == 49 || kind == 50 || kind == 51 || kind == 52 || kind == 15)
	{
		for (int i = 0; i < level; ++i)
		{
			System.out.print("    ");
		}

   		System.out.println("    " + name);
	}

    int numChildren = node.jjtGetNumChildren();
    for(int i = 0; i <  numChildren; ++i)
    {
      printTree((SimpleNode)node.jjtGetChild(i), level + 1);
    }

    for (int i = 0; i < level; ++i)
    {
    	System.out.print("    ");
    }

	String end = String.format("</%s>", node.toString());
    System.out.println(end);
  }
}

PARSER_END(SmallCC)


SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r\n"
}

TOKEN :
{
    <BREAK : "break">
  | <CASE: "case">
  | <CONTINUE: "continue">
  | <_DEFAULT: "default">
  | <DO: "do">
  | <ELSE: "else">
  | <FOR: "for">
  | <GOTO: "goto">
  | <IF: "if">
  | <INT: "int">
  | <CHAR: "char">
  | <LONG: "long">
  | <RETURN: "return">
  | <SHORT: "short">
  | <SIZEOF: "sizeof">
  | <STATIC: "static">
  | <SWITCH: "switch">
  | <TYPEDEF: "typedef">
  | <UNSIGNED: "unsigned">
  | <WHILE: "while">
  | <SEMI_COLON: ";">
  | <PLUS_PLUS: "++">
  | <MINUS_MINUS: "--">
  | <PLUS: "+">
  | <MINUS: "-">
  | <STAR: "*">
  | <DIVIDE: "/">
  | <MOD: "%">
  | <BIT_AND: "&">
  | <BIT_OR: "|">
  | <BIT_XOR: "^">
  | <BIT_NOT: "~">
  | <BOOLEAN_NOT: "!">
  | <BOOLEAN_AND: "&&">
  | <BOOLEAN_OR: "||">
  | <GREATER_THAN: ">">
  | <LESS_THAN: "<">
  | <LEFT_SHIFT: "<<">
  | <RIGHT_SHIFT: ">>">
  | <EQUALS: "=">
  | <EQUALS_EQUALS: "==">
  | <NOT_EQUALS: "!=">
  | <L_PAREN: "(">
  | <R_PAREN: ")">

  | <IDENTIFIER : (<IDENTIFIER_CHAR>)(<IDENTIFIER_CHAR> | ["0"-"9","_"])*>
  | <NUMBER : (<DIGIT>)+>
  | <STRING_LIT : "\"" (~["\"", "\n", "\\"] | ("\\" ~[]))* "\"">
  | <CHARACTER_CONST  : "\'" (~["\'", "\n", "\\"] | ("\\" ~[]))* "\'">
  | <COMMENT: <LINE_COMMENT> | <MULTI_LINE_COMMENT>>
  | <LINE_COMMENT : "//" (~["\n"])* <NEWLINE> >
  | <MULTI_LINE_COMMENT: "/*" (~["*"] | ("*")* ~["/"])* "*/">
  | <NEWLINE : "\r\n" | "\n" >
  | <#NOT_NEWLINE : ~["\n","\r"]>
  | <#IDENTIFIER_CHAR : ["A"-"Z","a"-"z","_"]>
  | <#DIGIT : ["0"-"9"]>
 }

/** Main production. */

Program program() throws Exception : {
	Program program = new Program();
	List<Initializer> initList;
	FunctionDefinition func;
}
{
  		(initList = globalVariableDeclaration() {
				System.out.println(initList.size());
				for (Initializer init : initList) {
					program.addInitializer(init);
				}
			}
				| functionDeclaration()
				| func = functionDefinition() {
					program.addFunction(func);
				}
			)*
  		{
				return program;
			}
}

Type bareType(): {}
{
  ("char" {return Type.charType;} | "int" {return Type.intType;})

}

void Type(): {}
{
  	bareType() ("*" #PointerType(1))*
}

List<Initializer> globalVariableDeclaration() : {
		List<Initializer> inits = new ArrayList<Initializer>();
		Type baseType = Type.intType;
}
{
	(baseType=bareType() )? inits=variableDeclarationList(baseType) ";"

	{
    	return inits;
	}
}

void localVariableDeclaration() : {
	Type baseType;
}
{
	baseType = bareType() variableDeclarationList(baseType) ";"
}

List<Initializer> variableDeclarationList(Type baseType) : {
	List<Initializer> inits = new ArrayList<Initializer>();
	Initializer init;
}
{
	init=variableInitializer(baseType) {
		if (init != null) inits.add(init);
	}
	("," variableInitializer(baseType) {
		if (init != null) inits.add(init);
	})*
	{
		return inits;
	}
}

Initializer variableInitializer(Type baseType) : {
	Initializer init = null;
	VariableExpression variable;
	Expression value = null;
}
{
	variable = suffixedVariable(baseType) ("=" value=expression() {
		if (value != null) init = new Initializer(variable, value);
	})?
	{
		return init;
	}
}

//here is where we add it to our SymbolTable, since we know
//the full type
VariableExpression suffixedVariable(Type baseType) : {
	Pair<Type,String> pair;
	Expression arraySize = null;
	int size = -1;
	Type type;
	Expression variable;
}
{
	(pair=PrefixedVariable(baseType) "[" (arraySize = expression()) "]" {
		arraySize = arraySize.collapse();
		if (!(arraySize instanceof ConstantExpression)) {
			throw new NonConstantExpressionException(arraySize);
		}
		size = ((ConstantExpression) arraySize).getValue();
		type = new ArrayType(size, pair.a);
	}
	/* we don't currently support non-sized arrays
	| PrefixedVariable() "[" "]" */
	| pair=PrefixedVariable(baseType) {
		type = pair.a;
	})
	{
		return SmallCC.variableTable.add(pair.b, type);
	}
}

Pair<Type,String> PrefixedVariable(Type baseType) : {
	Pair<Type,String> pair = new Pair<Type,String>();
	pair.a = baseType;
}
{
	(pair.b=Identifier()
	| "*" PrefixedVariable(new PointerType(baseType)))
	{
		return pair;
	}
}


FunctionDeclaration functionDeclaration() : {}
{
    Type() Identifier() ("(" (FunctionDeclarationParameter() ("," FunctionDeclarationParameter())*)? ")") #ParameterList ";"

	{
		return new FunctionDeclaration(null, null);
	}
}

void FunctionDeclarationParameter(): {}
{
    (Type() (Identifier())? | Identifier()) ("[" (expression())? "]")?

}

FunctionDefinition functionDefinition() : {}
{

    (Type())? Identifier()

		(("(" (FunctionDefinitionParameter() ("," FunctionDefinitionParameter())*)? ")" ) #ParameterList)
        ("{" (localVariableDeclaration())* (Statement())* "}"
		) #FunctionBody
		{
			return null;
		}
}

void FunctionDefinitionParameter(): {}
{
    (Type())? Identifier()
	{
		System.out.println("TODO function carp");
	}
	("[" (expression())? "]")?
}

void Statement() #void() : {}
{
		";" #NullStatement(0)
    | expression() ";" #expressionStatement(1)
    | ("{"  (localVariableDeclaration())* (Statement())* "}" ) #BlockStatement()
    | "if" "(" expression() ")" Statement() #IfStatement(2)
    | "while" "(" expression() ")" Statement() #WhileStatement(2)
    | "for" "(" (expression()";"| ";" #EmptyExpression(0)) (expression() ";" | ";" #EmptyExpression(0)) (expression() ")" | ")" #EmptyExpression(0)) Statement() #ForStatement(4)
    | "do" Statement() "while" "(" expression() ")" ";" #DoWhileExpression()
    /* There is an issue here, the block statement in the switch statement isn't taking on any children.  You might have to
     * make another production rule for a switch statement body that looks like a block statement with cases. */
    | "switch" "(" expression() ")" CaseBlock() #SwitchStatement(2)
    | "break" ";" #BreakStatement(0)
    | "continue" ";" #ContinueStatement(0)
    | "return" (expression())? ";" #ReturnStatement
    | Identifier() ":" Statement() #LabeledStatement(2)
    | "goto" Identifier() ";" #GotoStatement(1)
}

void CaseStatement() : {}
{
	(("case" expression() | "default") ":" (CaseStatement() | Statement()))
}

void CaseBlock() : {}
{
	"{" (localVariableDeclaration())* (Statement() | CaseStatement()) * "}"
}

/** Left-to-right*/
Expression expression() : {
	Expression l = null;
	Expression r = null;
}
{
    l = assignmentExpression() ("," r = assignmentExpression() {
			//l = new CommaExpression(l, r);
		})*
    {
			return l;
		}
}

/** Right-to-left */
Expression assignmentExpression() : {
	Expression l = null, r = null;
}
{
    (l = TernaryExpression()
			( "+=" r = assignmentExpression() {
				r = new AddExpression(l, r);
			}
			| "-=" r = assignmentExpression() {
				r = new SubtractExpression(l, r);
			}
			| "*=" r = assignmentExpression() {
				//r = new MultiplyExpression(l, r);
			}
			| "/=" r = assignmentExpression() {
				//r = new DivideExpression(l, r);
			}
			| "%=" r = assignmentExpression() {
				//r = new ModExpression(l, r);
			}
			| ">>=" r = assignmentExpression() {
				//r = new RightShiftExpression(l, r);
			}
			| "<<=" r = assignmentExpression() {
				//r = new LeftShiftExpression(l, r);
			}
			| "&=" r = assignmentExpression() {
				//r = new AndExpression(l, r);
			}
			| "^=" r = assignmentExpression() {
				//r = new XorExpression(l, r);
			}
			| "|=" r = assignmentExpression() {
				//r = new OrExpression(l, r);
			}
			| "=" r = assignmentExpression())?
		) {
				if (r != null) {
					if (l instanceof LValue)
						return new AssignmentExpression((LValue)l, r);
					else throw new Exception(l + " is not an LValue");
				} else {
					return l;
				}
			}
}

Expression TernaryExpression() : {
	Expression l = null, t = null, f = null;
}
{
    (l = OrExpression() ("?" t = expression() ":" f = TernaryExpression() #ConditionalOperator(3))?)
    {
		/*
		if (t != null && f != null)
		{
			if (l instanceof LValue)
				return new TernaryExpression((LValue)l,t,f);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

/** left-to-right*/

Expression OrExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = AndExpression() ("||" r = AndExpression() #Or(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new OrExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression AndExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = BitOrExpression() ("&&" r = BitOrExpression() #And(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new AndExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression BitOrExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = BitXorExpression() ("|" r = BitXorExpression() #BitOr(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new BitOrExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression BitXorExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = BitAndExpression() ("^" r = BitAndExpression() #BitXor(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new BitXorExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression BitAndExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = EqualityExpression() ("&" r = EqualityExpression() #BitAnd(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new BitAndExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression EqualityExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = GreaterThanExpression() ( "==" r = GreaterThanExpression() #Equal(2)
                            | "!=" r = GreaterThanExpression() #NotEqual(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new EqualityExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression GreaterThanExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = LessThanExpression() ( ">" r = LessThanExpression() #GreaterThan(2)
                         | ">=" r = LessThanExpression() #GreaterThanOrEqual(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new GreaterThanExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression LessThanExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = BitshiftExpression() ( "<" r = BitshiftExpression() #LessThan(2)
		                     | "<=" r = BitshiftExpression() #LessThanOrEqual(2) )*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new LessThanExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression BitshiftExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = AdditiveExpression() ( "<<" r = AdditiveExpression() #LeftShift(2)
		                     | ">>" r = AdditiveExpression() #RightShift(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new LessThanExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression AdditiveExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = MultiplicativeExpression() ( "+" r = MultiplicativeExpression() #Add(2)
                               | "-" r = MultiplicativeExpression() #Subtract(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new LessThanExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression MultiplicativeExpression() #void() : {
	Expression l = null, r = null;
}
{
    l = PrefixExpression() ( "*" r = PrefixExpression() #Multiply(2)
                       | "/" r = PrefixExpression() #Divide(2)
                       | "%" r = PrefixExpression() #Modulo(2))*
	{
		/*
		if (r != null)
		{
			if (l instanceof LValue)
				return new LessThanExpression((LValue)l,r);
			else throw new Exception(l + " is not an LValue");
		}
		else
			return l;
			*/
		return null;
	}
}

Expression PrefixExpression() #void() : {}
{
    // issue on the cast. It breaks if((x&y) == 1) {y++;} because it captures the second "(" and thinks type is next
    // TODO add casting back: "(" Type() ")"
    (SuffixExpression()
    | "++" PrefixExpression() #PreIncrement(1)
    | "--" PrefixExpression() #PreDecrement(1)
    | "+" PrefixExpression() #Positive(1)
    | "-" PrefixExpression() #Negative(1)
    | "!" PrefixExpression() #Not(1)
    | "~" PrefixExpression() #BitNot(1)
    | "*" PrefixExpression() #Dereference(1)
    | "&" PrefixExpression() #AddressOf(1)
    | "sizeof" PrefixExpression() #Sizeof(1)
    | "(" Type() ")" PrefixExpression() #Cast(2))
	{
		return null;
	}

}

void SuffixExpression() #void() : {}
{
    AtomicExpression()
			( "++" #PostIncrement(1)
			| "--" #PostDecrement(1)
			| "(" expression() ")" #FunctionCall(2)
			| "[" expression() "]" #ArrayAccess(2))*
}

void AtomicExpression() #void() : {}
{
   Identifier()
    | Number()
    | StringLiteral()
    | CharacterConstant()
    | "(" expression() ")"
}

String Identifier() : {}
{
    <IDENTIFIER>
    {
			return token.image;
		}
}

void CharacterConstant() : {}
{
    <CHARACTER_CONST>
}

void Number() : {}
{
    <NUMBER>
}

void StringLiteral() : {}
{
    <STRING_LIT>
}

void Boolean_Not() : {}
{
    <BOOLEAN_NOT>
}

void Boolean_And() : {}
{
    <BOOLEAN_AND>
}

void Boolean_Or() : {}
{
    <BOOLEAN_OR>
}

void Bit_Not() : {}
{
    <BIT_NOT>
}

void Bit_And() : {}
{
    <BIT_AND>
}

void Bit_Or() : {}
{
    <BIT_OR>
}

void Bit_Xor() : {}
{
    <BIT_XOR>
}

void Left_Shift() : {}
{
    <LEFT_SHIFT>
}
void Right_Shift() : {}
{
    <RIGHT_SHIFT>

}

void R_Paren() : {}
{
    <R_PAREN>
}

void L_Paren() : {}
{
    <L_PAREN>
}

void Plus() : {}
{
    <PLUS>
}

void Plus_Plus() : {}
{
    <PLUS_PLUS>
}

void Minus() : {}
{
    <MINUS>
}

void Minus_Minus() : {}
{
    <MINUS_MINUS>
}

void Star(): {}
{
    <STAR>

}

void Mod() : {}
{
    <MOD>
}

void Divide() : {}
{
    <DIVIDE>
}

void Equals() : {}
{
    <EQUALS>
}

void Less_Than() : {}
{
    <LESS_THAN>
}

void Greater_Than() : {}
{
    <GREATER_THAN>
}

void Equals_Equals() #void : {}
{
    <EQUALS_EQUALS>
}

void Not_Equals() : {}
{
    <NOT_EQUALS>
}

JAVACODE
String handleError(ParseException ex) #void
{
	Token token = ex.currentToken;
	System.out.println(ex.getMessage());

	do {
		token = getNextToken();
	} while (token.kind != SEMI_COLON);

	jjtree.popNode();
	return token.image;
}
