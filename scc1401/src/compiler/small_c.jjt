/*
	small_c.jj

    Assignment #7 - CS153 - SJSU
	November-18-2014

	By Sean Papay, Matt Pleva, Luca Severini
*/

options
{
	DEBUG_PARSER=false;// true;
	LOOKAHEAD=99999;
  //NODE_CLASS="MyNode";
}

PARSER_BEGIN(SmallCC)

package compiler;
import java.util.*;
import preprocessor.*;
import retree.*;
import retree.expression.*;
import retree.exceptions.*;
import retree.program.*;
import retree.type.*;
import retree.symtab.*;
import java.io.*;

public class SmallCC
{
	// used during tree build
  public static SymbolTableStack variableTable = new SymbolTableStack();

  private static int labelNumber = 0;

  public static String nextLabel() {
		//all our generated labels will start with a L
		String label = "L";
		int n = labelNumber++;
		while (label.length() < 6) {
			label += ('A' + n%26);
			n /= 26;
		}
		return label;
	}

  public static void main(String args[]) throws Exception
  {
		compile(args[0]);
  }

  public static void compile(String fileName) throws Exception
  {
    File file = new File(fileName);
    Reader sr = new FileReader(file);

    SmallCC parser = new SmallCC(sr);
    Program program = parser.program();
    System.out.print(program.generateCode());
		//printTree(program);

  }

  public static void printTree(SimpleNode node)
  {
  	System.out.println("===== AST (parse tree) =====");

    printTree(node, 0);
  }

  public static void printTree(SimpleNode node, int level)
  {
    for (int i = 0; i < level; ++i)
    {
    	System.out.print("    ");
    }

	MyNode n = (MyNode)node;
	int kind = n.getKind();
	String name = n.getName();

	String begin = String.format("<%s>", node.toString());
    System.out.println(begin);

    // System.out.println(kind);

	if(kind == 49 || kind == 50 || kind == 51 || kind == 52 || kind == 15)
	{
		for (int i = 0; i < level; ++i)
		{
			System.out.print("    ");
		}

   		System.out.println("    " + name);
	}

    int numChildren = node.jjtGetNumChildren();
    for(int i = 0; i <  numChildren; ++i)
    {
      printTree((SimpleNode)node.jjtGetChild(i), level + 1);
    }

    for (int i = 0; i < level; ++i)
    {
    	System.out.print("    ");
    }

	String end = String.format("</%s>", node.toString());
    System.out.println(end);
  }
}

PARSER_END(SmallCC)


SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r\n"
}

TOKEN :
{
    <BREAK : "break">
  | <CASE: "case">
  | <CONTINUE: "continue">
  | <_DEFAULT: "default">
  | <DO: "do">
  | <ELSE: "else">
  | <FOR: "for">
  | <GOTO: "goto">
  | <IF: "if">
  | <INT: "int">
  | <CHAR: "char">
  | <LONG: "long">
  | <RETURN: "return">
  | <SHORT: "short">
  | <SIZEOF: "sizeof">
  | <STATIC: "static">
  | <SWITCH: "switch">
  | <TYPEDEF: "typedef">
  | <UNSIGNED: "unsigned">
  | <WHILE: "while">
  | <SEMI_COLON: ";">
  | <PLUS_PLUS: "++">
  | <MINUS_MINUS: "--">
  | <PLUS: "+">
  | <MINUS: "-">
  | <STAR: "*">
  | <DIVIDE: "/">
  | <MOD: "%">
  | <BIT_AND: "&">
  | <BIT_OR: "|">
  | <BIT_XOR: "^">
  | <BIT_NOT: "~">
  | <BOOLEAN_NOT: "!">
  | <BOOLEAN_AND: "&&">
  | <BOOLEAN_OR: "||">
  | <GREATER_THAN: ">">
  | <LESS_THAN: "<">
  | <LEFT_SHIFT: "<<">
  | <RIGHT_SHIFT: ">>">
  | <EQUALS: "=">
  | <EQUALS_EQUALS: "==">
  | <NOT_EQUALS: "!=">
  | <L_PAREN: "(">
  | <R_PAREN: ")">

  | <IDENTIFIER : (<IDENTIFIER_CHAR>)(<IDENTIFIER_CHAR> | ["0"-"9","_"])*>
  | <NUMBER : (<DIGIT>)+>
  | <STRING_LIT : "\"" (~["\"", "\n", "\\"] | ("\\" ~[]))* "\"">
  | <CHARACTER_CONST  : "\'" (~["\'", "\n", "\\"] | ("\\" ~[]))* "\'">
  | <COMMENT: <LINE_COMMENT> | <MULTI_LINE_COMMENT>>
  | <LINE_COMMENT : "//" (~["\n"])* <NEWLINE> >
  | <MULTI_LINE_COMMENT: "/*" (~["*"] | ("*")* ~["/"])* "*/">
  | <NEWLINE : "\r\n" | "\n" >
  | <#NOT_NEWLINE : ~["\n","\r"]>
  | <#IDENTIFIER_CHAR : ["A"-"Z","a"-"z","_"]>
  | <#DIGIT : ["0"-"9"]>
 }

/** Main production. */

Program program() throws Exception : {
	Program program = new Program();
	List<Initializer> initList;
	FunctionDefinition func;
}
{
  		(initList = globalVariableDeclaration() {
				//System.out.println(initList.size());
				for (Initializer init : initList) {
					program.addInitializer(init);
				}
			}
				| functionDeclaration() //not supported just yet...
				| func = functionDefinition() {
					program.addFunction(func);
				}
			)*
  		{
				return program;
			}
}

Type bareType(): {}
{
  ("char" {return Type.charType;} | "int" {return Type.intType;})

}

Type Type(): {
	Type t;
}
{
  	(t = bareType() ("*" {t = new PointerType(t);} )*) {return t;}
}

List<Initializer> globalVariableDeclaration() : {
		List<Initializer> inits = new ArrayList<Initializer>();
		Type baseType = Type.intType;
}
{
	(baseType=bareType() )? inits=variableDeclarationList(baseType) ";"

	{
    	return inits;
	}
}

void localVariableDeclaration() : {
	Type baseType;
}
{
	baseType = bareType() variableDeclarationList(baseType) ";"
}

List<Initializer> variableDeclarationList(Type baseType) : {
	List<Initializer> inits = new ArrayList<Initializer>();
	Initializer init;
}
{
	init=variableInitializer(baseType) {
		if (init != null) inits.add(init);
	}
	("," variableInitializer(baseType) {
		if (init != null) inits.add(init);
	})*
	{
		return inits;
	}
}

Initializer variableInitializer(Type baseType) : {
	Initializer init = null;
	VariableExpression variable;
	Expression value = null;
}
{
	variable = suffixedVariable(baseType) ("=" value=expression() {
		if (value != null) init = new Initializer(variable, value);
	})?
	{
		return init;
	}
}

//here is where we add it to our SymbolTable, since we know
//the full type
VariableExpression suffixedVariable(Type baseType) : {
	Pair<Type,String> pair;
	Expression arraySize = null;
	int size = -1;
	Type type;
	Expression variable;
}
{
	(pair=PrefixedVariable(baseType) "[" (arraySize = expression()) "]" {
		arraySize = arraySize.collapse();
		if (!(arraySize instanceof ConstantExpression)) {
			throw new NonConstantExpressionException(arraySize);
		}
		size = ((ConstantExpression) arraySize).getValue();
		type = new ArrayType(size, pair.a);
	}
	/* we don't currently support non-sized arrays
	| PrefixedVariable() "[" "]" */
	| pair=PrefixedVariable(baseType) {
		type = pair.a;
	})
	{
		return SmallCC.variableTable.add(pair.b, type);
	}
}

Pair<Type,String> PrefixedVariable(Type baseType) : {
	Pair<Type,String> pair = new Pair<Type,String>();
	pair.a = baseType;
}
{
	(pair.b=Identifier()
	| "*" PrefixedVariable(new PointerType(baseType)))
	{
		return pair;
	}
}


FunctionDeclaration functionDeclaration() : {}
{
    Type() Identifier() ("(" (FunctionDeclarationParameter() ("," FunctionDeclarationParameter())*)? ")")  ";"

	{
		return new FunctionDeclaration(null, null);
	}
}

void FunctionDeclarationParameter(): {}
{
    (Type() (Identifier())? | Identifier()) ("[" (expression())? "]")?

}

FunctionDefinition functionDefinition() : {}
{

    (Type())? Identifier()

		(("(" (FunctionDefinitionParameter() ("," FunctionDefinitionParameter())*)? ")" ) )
        ("{" (localVariableDeclaration())* (Statement())* "}"
		)
		{
			return null;
		}
}

void FunctionDefinitionParameter(): {}
{
    (Type())? Identifier()
	{
		System.out.println("TODO function carp");
	}
	("[" (expression())? "]")?
}

void Statement()  : {}
{
		";"
    | expression() ";"
    | ("{"  (localVariableDeclaration())* (Statement())* "}" )
    | "if" "(" expression() ")" Statement()
    | "while" "(" expression() ")" Statement()
    | "for" "(" (expression()";"| ";" ) (expression() ";" | ";" ) (expression() ")" | ")" ) Statement()
    | "do" Statement() "while" "(" expression() ")" ";"
    /* There is an issue here, the block statement in the switch statement isn't taking on any children.  You might have to
     * make another production rule for a switch statement body that looks like a block statement with cases. */
    | "switch" "(" expression() ")" CaseBlock()
    | "break" ";"
    | "continue" ";"
    | "return" (expression())? ";"
    | Identifier() ":" Statement()
    | "goto" Identifier() ";"
}

void CaseStatement() : {}
{
	(("case" expression() | "default") ":" (CaseStatement() | Statement()))
}

void CaseBlock() : {}
{
	"{" (localVariableDeclaration())* (Statement() | CaseStatement()) * "}"
}

/** Left-to-right*/
Expression expression() : {
	Expression l = null;
	Expression r = null;
}
{
    l = assignmentExpression() ("," r = assignmentExpression() {
			//l = new CommaExpression(l, r);
		})*
    {
			return l;
	}
}

/** Right-to-left */
Expression assignmentExpression() : {
	Expression l = null, r = null;
}
{
    (l = ternaryExpression()
			( "+=" r = assignmentExpression() {
				r = new AddExpression(l, r);
			}
			| "-=" r = assignmentExpression() {
				r = new SubtractExpression(l, r);
			}
			| "*=" r = assignmentExpression() {
				//r = new MultiplyExpression(l, r);
			}
			| "/=" r = assignmentExpression() {
				//r = new DivideExpression(l, r);
			}
			| "%=" r = assignmentExpression() {
				//r = new ModExpression(l, r);
			}
			| ">>=" r = assignmentExpression() {
				//r = new RightShiftExpression(l, r);
			}
			| "<<=" r = assignmentExpression() {
				//r = new LeftShiftExpression(l, r);
			}
			| "&=" r = assignmentExpression() {
				//r = new AndExpression(l, r);
			}
			| "^=" r = assignmentExpression() {
				//r = new XorExpression(l, r);
			}
			| "|=" r = assignmentExpression() {
				//r = new OrExpression(l, r);
			}
			| "=" r = assignmentExpression())?
		) {
				if (r != null) {
					if (l instanceof LValue)
						return new AssignmentExpression((LValue)l, r);
					else throw new Exception(l + " is not an LValue");
				} else {
					return l;
				}
			}
}

Expression ternaryExpression() : {
	Expression l = null, t = null, f = null;
}
{
    (l = orExpression() ("?" t = expression() ":" f = ternaryExpression() )?)
    {
		/*
		if (t != null && f != null)
		{
			return new TernaryExpression(l,t,f);
		}
		*/
		return l;
	}
}

/** left-to-right*/

Expression orExpression() : {
	Expression l = null, r = null;
}
{
    l = andExpression() ("||" r = andExpression() {
			/*
			l = new OrExpression(l, r);
			*/
		})*
	{
		return l;
	}
}

Expression andExpression() : {
	Expression l = null, r = null;
}
{
    l = bitOrExpression() ("&&" r = bitOrExpression() {
		/*
		l = new AndExpression(l, r);
		*/
		})*
	{
		return l;
	}
}

Expression bitOrExpression() : {
	Expression l = null, r = null;
}
{
    l = bitXorExpression() ("|" r = bitXorExpression() {
			/*
			l = new BitOrExpression(l, r);
			*/
		})*
	{
		return l;
	}
}

Expression bitXorExpression() : {
	Expression l = null, r = null;
}
{
    l = bitAndExpression() ("^" r = bitAndExpression() {
			/*
			l = new BitXorExpression(l, r);
			*/
		})*
	{
		return l;
	}
}

Expression bitAndExpression() : {
	Expression l = null, r = null;
}
{
    l = equalityExpression() ("&" r = equalityExpression() {
			/*
			l = new BitAndExpression(l, r);
			*/
		})*
	{
		return l;
	}
}

Expression equalityExpression() : {
	Expression l = null, r = null;
}
{
    l = greaterThanExpression() ( "==" r = greaterThanExpression() {
			/*
			l = new EqualityExpression(l, r);
			*/

		}
    | "!=" r = greaterThanExpression() {
			/*
			l = new InequalityExpression(l, r);
			*/
		})*
	{
		return l;
	}
}

Expression greaterThanExpression() : {
	Expression l = null, r = null;
}
{
    l = lessThanExpression() ( ">" r = lessThanExpression() {
			/*
			l = new GreaterThanExpression(l, r);
			*/
		}
		| ">=" r = lessThanExpression() {
			/*
			l = new GreaterThanOrEqualExpression(l, r);
			*/
		})*
	{
		return l;
	}
}

Expression lessThanExpression() : {
	Expression l = null, r = null;
}
{
    l = bitshiftExpression() ( "<" r = bitshiftExpression() {
			/*
			l = new LessThanExpression(l, r);
			*/
		}
		| "<=" r = bitshiftExpression() {
			/*
			l = new LessThanOrEqualExpression(l, r);
			*/
		})*
	{
		return l;
	}
}

Expression bitshiftExpression()  : {
	Expression l = null, r = null;
}
{
    l = additiveExpression() ( "<<" r = additiveExpression(){
			/*
			l = new BitshiftExpression(l, r);
			*/
		}
		| ">>" r = additiveExpression(){
			/*
			l = new BitshiftExpression(l, r);
			*/
		} )*
	{
		return l;
	}
}

Expression additiveExpression()  : {
	Expression l = null, r = null;
}
{
    l = multiplicativeExpression() ( "+" r = multiplicativeExpression(){
			/*
			l = new AdditiveExpression(l, r);
			*/
		}
        | "-" r = multiplicativeExpression(){
			/*
			l = new SubtractExpression(l, r);
			*/
		} )*
	{
		return l;
	}
}

Expression multiplicativeExpression()  : {
	Expression l = null, r = null;
}
{
    (l = prefixExpression() ( "*" r = prefixExpression(){
		/*
			l = new MultiplicationExpression(l, r);
		*/
	}
    | "/" r = prefixExpression(){
		/*
			l = new DivideExpression(l, r);
		*/
	}
    | "%" r = prefixExpression(){
		/*
			l = new ModExpression(l, r);
		*/
	} )*)
	{
		return l;
	}
}

Expression prefixExpression()  : {
	Expression e;
	Type t;
}
{
    // issue on the cast. It breaks if((x&y) == 1) {y++;} because it captures the second "(" and thinks type is next
    // TODO add casting back: "(" Type() ")"
    (e = SuffixExpression()
    | "++" e = prefixExpression()	{
										// e = new PreIncrementExpression(e);
									}
    | "--" e = prefixExpression()	{
										// e = new PreDecrementExpression(e);
									}
    | "+" e = prefixExpression()	{
										// e = new PositiveExpression(e);
									}
    | "-" e = prefixExpression()	{
										// e = new NegativeExpression(e);
									}
    | "!" e = prefixExpression()	{
										// e = new NotExpression(e);
									}
    | "~" e = prefixExpression()	{
										// e = new BitNotExpression(e);
									}
    | "*" e = prefixExpression()	{
										e = new DereferenceExpression(e);
									}
    | "&" e = prefixExpression()	{
										e = new AddressOfExpression((LValue)e);
									}
    | "sizeof" e = prefixExpression()	{
											// e = new SizeOfExpression(e);
										}
    | "(" t = Type() ")" e = prefixExpression()	{
													// e = new CastExpression(t,e);
												}
	)
	{
		return e;
	}

}

Expression SuffixExpression()  : {
	Expression e, inside;
}
{
    (e = AtomicExpression()
			( "++"	{
						// e = new PostIncrementExpression(e);
					}
			| "--"	{
						// e = new PostDecrementExpression(e);
					}
			| "(" inside = expression() ")" {
												// e = new FunctionCallExpression(e,inside);
											}
			| "[" inside = expression() "]" {
												// e = new ArrayAccessExpression(e,inside);
											} )*)
			{
				return e;
			}
}

Expression AtomicExpression()  : {
	Expression e = null;
	ConstantExpression ce = null;
	String str = "";
}
{
   (str = Identifier() {
		VariableExpression var = variableTable.searchStack(str);
		if (var == null){
			return null;
		} else {
			return var;
		}
	}
    | Number(){
		int val = Integer.parseInt(str);
		ce = new ConstantExpression(Type.intType, val);
		e = ce;
	}
    | StringLiteral()
    | CharacterConstant(){
		ce = new ConstantExpression(Type.charType, 65);
		e = ce;
	}
    | "(" expression() ")")
	{

		return e;
	}
}

String Identifier() : {}
{
    <IDENTIFIER>
    {
		return token.image;
	}
}

String CharacterConstant() : {}
{
    <CHARACTER_CONST>
	{
		System.out.println("char: " + token.image);
		return token.image;
	}
}

String Number() : {}
{
    <NUMBER>
	{
		return token.image;
	}
}

String StringLiteral() : {}
{
    <STRING_LIT>
	{
		return token.image;
	}
}

void Boolean_Not() : {}
{
    <BOOLEAN_NOT>
}

void Boolean_And() : {}
{
    <BOOLEAN_AND>
}

void Boolean_Or() : {}
{
    <BOOLEAN_OR>
}

void Bit_Not() : {}
{
    <BIT_NOT>
}

void Bit_And() : {}
{
    <BIT_AND>
}

void Bit_Or() : {}
{
    <BIT_OR>
}

void Bit_Xor() : {}
{
    <BIT_XOR>
}

void Left_Shift() : {}
{
    <LEFT_SHIFT>
}
void Right_Shift() : {}
{
    <RIGHT_SHIFT>

}

void R_Paren() : {}
{
    <R_PAREN>
}

void L_Paren() : {}
{
    <L_PAREN>
}

void Plus() : {}
{
    <PLUS>
}

void Plus_Plus() : {}
{
    <PLUS_PLUS>
}

void Minus() : {}
{
    <MINUS>
}

void Minus_Minus() : {}
{
    <MINUS_MINUS>
}

void Star(): {}
{
    <STAR>

}

void Mod() : {}
{
    <MOD>
}

void Divide() : {}
{
    <DIVIDE>
}

void Equals() : {}
{
    <EQUALS>
}

void Less_Than() : {}
{
    <LESS_THAN>
}

void Greater_Than() : {}
{
    <GREATER_THAN>
}

void Equals_Equals()  : {}
{
    <EQUALS_EQUALS>
}

void Not_Equals() : {}
{
    <NOT_EQUALS>
}

JAVACODE
String handleError(ParseException ex)
{
	Token token = ex.currentToken;
	System.out.println(ex.getMessage());

	do {
		token = getNextToken();
	} while (token.kind != SEMI_COLON);

	jjtree.popNode();
	return token.image;
}
