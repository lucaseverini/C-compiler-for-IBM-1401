/*
	small_c.jj

    Assignment #6 - CS153 - SJSU
	November-8-2014

	By Sean Papay, Matt Pleva, Luca Severini
*/

options
{
	DEBUG_PARSER=false;// true;
	LOOKAHEAD = 99999;
}

PARSER_BEGIN(SmallCC)

package compiler;

import preprocessor.*;
import java.io.*;

public class SmallCC
{
  public static void main(String args[]) throws Exception
  {
    compile(args[0]);
  }

  public static void compile(String fileName) throws Exception
  {
    File file = new File(fileName);
    Reader sr = new FileReader(file);
    /*
      line continuations and newline encoding are hard to keep
      track of at tokenization time, so we'll handle them
      directly in the reader
    */
    /*
    Reader sr = new FileReader(file) {
      private int[] lookahead = {-1, -1};
      public int read() throws IOException {
        if (lookahead[0] >= 0) {
          int ch = lookahead[0];
          lookahead[0] = lookahead[1];
          lookahead[1] = -1;
          return ch;
        }
        int ch = super.read();
        //possible line continuation
        if (ch == '\\') {
          lookahead[0] = super.read();

          if (lookahead[0] == '\r') {
            //the user is using windows, what a loser :P
            lookahead[1] = super.read();
            if (lookahead[1] != '\n') {
              //carriage return with no line feed, what's going on?
                                    // maybe we are printing a bold character or an underline
              return ch;
            } else {
              lookahead[0] = '\n';
            }
          }
          if (lookahead[0] == '\n') {
            lookahead[0] = lookahead[1] = -1;
            do {
              ch = super.read();
              if (ch < 0) return ch;
            } while(Character.isWhitespace((char) ch));
            return ch;
          }
        } else if (ch == '\r') {
          lookahead[0] = super.read();
          if (lookahead[0] == '\n') {
            lookahead[0] = lookahead[1] = -1;
            return '\n';
          }
        }
        return ch;
      }

      public int read(char[] cbuf, int offset, int length) throws IOException{
        int read = 0;
        while (read < length && offset + read < cbuf.length) {
          int ch = read();
          if (ch < 0) break;
          cbuf[offset + (read++)] = (char) ch;
        }
        if (read == 0 && read < length) return -1;
        return read;
      }
    };
    */
    SmallCC parser = new SmallCC(sr);
    SimpleNode program = parser.program();
    printTree(program);
  }

  public static void printTree(SimpleNode node) {
    printTree(node, 0);
  }

  public static void printTree(SimpleNode node, int level) {
    for (int i = 0; i < level; ++i) System.out.print("  ");
    System.out.println(node);
    int numChildren = node.jjtGetNumChildren();
    for(int i = 0; i <  numChildren; ++i) {
      printTree((SimpleNode)node.jjtGetChild(i), level + 1);
    }
  }

}


PARSER_END(SmallCC)

SKIP : {
    " "
  | "\t"
  | "\n"
  | "\r\n"
}

TOKEN : {
    <BREAK : "break">
  | <CASE: "case">
  | <CHAR: "char">
  | <CONTINUE: "continue">
  | <_DEFAULT: "default">
  | <DO: "do">
  | <ELSE: "else">
  | <FOR: "for">
  | <GOTO: "goto">
  | <IF: "if">
  | <INT: "int">
  | <LONG: "long">
  | <RETURN: "return">
  | <SHORT: "short">
  | <SIZEOF: "sizeof">
  | <STATIC: "static">
  | <SWITCH: "switch">
  | <TYPEDEF: "typedef">
  | <UNSIGNED: "unsigned">
  | <WHILE: "while">
  | <SEMI_COLON: ";">
  | <PLUS_PLUS: "++">
  | <MINUS_MINUS: "--">
  | <PLUS: "+">
  | <MINUS: "-">
  | <STAR: "*">
  | <DIVIDE: "/">
  | <MOD: "%">
  | <BIT_AND: "&">
  | <BIT_OR: "|">
  | <BIT_XOR: "^">
  | <BIT_NOT: "~">
  | <BOOLEAN_NOT: "!">
  | <BOOLEAN_AND: "&&">
  | <BOOLEAN_OR: "||">
  | <GREATER_THAN: ">">
  | <LESS_THAN: "<">
  | <LEFT_SHIFT: "<<">
  | <RIGHT_SHIFT: ">>">
  | <EQUALS: "=">
  | <EQUALS_EQUALS: "==">
  | <NOT_EQUALS: "!=">
  | <L_PAREN: "(">
  | <R_PAREN: ")">

  | <IDENTIFIER : (<IDENTIFIER_CHAR>)(<IDENTIFIER_CHAR> | ["0"-"9","_"])*>
  | <NUMBER : (<DIGIT>)+>
  | <STRING_LIT : "\"" (~["\"", "\n", "\\"] | ("\\" ~[]))* "\"">
  | <CHARACTER_CONST  : "\'" (~["\'", "\n", "\\"] | ("\\" ~[]))* "\'">
  | <COMMENT: <LINE_COMMENT> | <MULTI_LINE_COMMENT>>
  | <LINE_COMMENT : "//" (~["\n"])* <NEWLINE> >
  | <MULTI_LINE_COMMENT: "/*" (~["*"] | ("*")* ~["/"])* "*/">
  | <NEWLINE : "\r\n" | "\n" >
  | <#NOT_NEWLINE : ~["\n","\r"]>
  | <#IDENTIFIER_CHAR : ["A"-"Z","a"-"z","_"]>
  | <#DIGIT : ["0"-"9"]>
 }

/** Main production. */

SimpleNode program()  : {}
{
  (GlobalVariableDeclaration() | FunctionDeclaration() | FunctionDefinition())*
  {return jjtThis;}
}

void BareType(): {}
{
  "char" | "int"
}

void Type(): {}
{
  BareType() ("*")*
}

void GlobalVariableDeclaration() : {}
{
	(BareType())? VariableDeclarationList() ";"
}

void LocalVariableDeclaration() : {}
{
	BareType() VariableDeclarationList() ";"
}

void VariableDeclarationList() : {}
{
	VariableInitializer() ("," VariableInitializer())*
}

void VariableInitializer() #void :{}
{
	SuffixedVariable() ("=" AssignmentExpression() #Initializer(2))?
}

void SuffixedVariable() #void : {}
{
	PrefixedVariable() "[" (Expression()) "]" #ArrayDeclaration(2)
	| PrefixedVariable() "[" "]" #ArrayDeclaration(1)
	| PrefixedVariable()
}

void PrefixedVariable() #void :{}
{
	Identifier()
	| "*" PrefixedVariable() #PointerDeclaration(1)
}


void FunctionDeclaration() : {}
{
    Type() Identifier() ("(" (FunctionDeclarationParameter() ("," FunctionDeclarationParameter())*)? ")") #ParameterList ";"
}

void FunctionDeclarationParameter(): {}
{
    (Type() (Identifier())? | Identifier()) ("[" (Expression())? "]")?
}

void FunctionDefinition() : {}
{
    (Type())? Identifier() (("(" (FunctionDefinitionParameter() ("," FunctionDefinitionParameter())*)? ")" ) #ParameterList)
        ("{" (LocalVariableDeclaration())* (Statement())* "}") #FunctionBody
}

void FunctionDefinitionParameter(): {}
{
    (Type())? Identifier() ("[" (Expression())? "]")?
}

void Statement() #void() : {}
{
		";" #NullStatement(0)
    | Expression() ";" #ExpressionStatement(1)
    | ("{" (LocalVariableDeclaration())* (Statement())* "}") #BlockStatement()
    | "if" "(" Expression() ")" Statement() #IfStatement(2)
    | "while" "(" Expression() ")" Statement() #WhileStatement(2)
    | "for" "(" (Expression()";"| ";" #EmptyExpression(0)) (Expression() ";" | ";" #EmptyExpression(0)) (Expression() ")" | ")" #EmptyExpression(0)) Statement() #ForStatement(4)
    | "do" Statement() "while" "(" Expression() ")" ";" #DoWhileExpression()
    /* There is an issue here, the block statement in the switch statement isn't taking on any children.  You might have to
     * make another production rule for a switch statement body that looks like a block statement with cases. */
    | "switch" "(" Expression() ")" ("{" (LocalVariableDeclaration())* (("case" Expression() ":" | "default" ":")? Statement())* "}" #BlockStatenent ) #SwitchStatement
    | "break" ";" #BreakStatement(0)
    | "continue" ";" #ContinueStatement(0)
    | "return" (Expression())? ";" #ReturnStatement
    | Identifier() ":" Statement() #LabeledStatement(2)
    | "goto" Identifier() ";" #GotoStatement(1)
}

/** Left-to-right*/
void Expression() #void: {}
{
    AssignmentExpression() ("," AssignmentExpression() #Comma(2))*
}
/** Right-to-left */
void AssignmentExpression() #void: {}
{
    TernaryExpression() ( "+=" AssignmentExpression() #AddAssign(2) 
                        | "-=" AssignmentExpression() #SubtractAssign(2)
                        | "*=" AssignmentExpression() #MultiplyAsign(2)
                        | "/=" AssignmentExpression() #DivideAssign(2)
                        | "%=" AssignmentExpression() #ModuloAssign(2)
                        | ">>=" AssignmentExpression() #RightShiftAssign(2)
                        | "<<=" AssignmentExpression() #LeftShiftAssign(2)
												| "&=" AssignmentExpression() #BitAndAssign(2)
												| "^=" AssignmentExpression() #BitXorAssign(2)
												| "|=" AssignmentExpression() #BitXorAssign(2)
												| "=" AssignmentExpression() #Assign(2))?
}

void TernaryExpression() #void: {}
{
    OrExpression() ("?" Expression() ":" TernaryExpression() #ConditionalOperator(3))?
}

/** left-to-right*/

void OrExpression() #void() : {}
{
    AndExpression() ("||" AndExpression() #Or(2))*
}

void AndExpression() #void() : {}
{
    BitOrExpression() ("&&" BitOrExpression() #And(2))*
}

void BitOrExpression() #void() : {}
{
    BitXorExpression() ("|" BitXorExpression() #BitOr(2))*
}

void BitXorExpression() #void() : {}
{
    BitAndExpression() ("^" BitAndExpression() #BitXor(2))*

}

void BitAndExpression() #void() : {}
{
    EqualityExpression() ("&" EqualityExpression() #BitAnd(2))*
}

void EqualityExpression() #void() : {}
{
    GreaterThanExpression() ( "==" GreaterThanExpression() #Equal(2)
                            | "!=" GreaterThanExpression() #NotEqual(2))*
}

void GreaterThanExpression() #void() : {}
{
    LessThanExpression() ( ">" LessThanExpression() #GreaterThan(2)
                         | ">=" LessThanExpression() #GreaterThanOrEqual(2))*
}

void LessThanExpression() #void() : {}
{
    BitshiftExpression() ( "<" BitshiftExpression() #LessThan(2)
		                     | "<=" BitshiftExpression() #LessThanOrEqual(2) )*
}

void BitshiftExpression() #void() : {}
{
    AdditiveExpression() ( "<<" AdditiveExpression() #LeftShift(2)
		                     | ">>" AdditiveExpression() #RightShift(2))*
}

void AdditiveExpression() #void() : {}
{
    MultiplicativeExpression() ( "+" MultiplicativeExpression() #Add(2)
                               | "-" MultiplicativeExpression() #Subtract(2))*
}

void MultiplicativeExpression() #void() : {}
{
    PrefixExpression() ( "*" PrefixExpression() #Multiply(2)
                       | "/" PrefixExpression() #Divide(2)
                       | "%" PrefixExpression() #Modulo(2))*
}

void PrefixExpression() #void() : {}
{
    // issue on the cast. It breaks if((x&y) == 1) {y++;} because it captures the second "(" and thinks type is next
    // TODO add casting back: "(" Type() ")"
    SuffixExpression()
    | "++" PrefixExpression() #PreIncrement(1)
    | "--" PrefixExpression() #PreDecrement(1)
    | "+" PrefixExpression() #Positive(1)
    | "-" PrefixExpression() #Negative(1)
    | "!" PrefixExpression() #Not(1)
    | "~" PrefixExpression() #BitNot(1)
    | "*" PrefixExpression() #Dereference(1)
    | "&" PrefixExpression() #AddressOf(1)
    | "sizeof" PrefixExpression() #Sizeof(1)
    | "(" Type() ")" PrefixExpression() #Cast(2)
}

void SuffixExpression() #void() : {}
{
    AtomicExpression() 
			( "++" #PostIncrement(1)
			| "--" #PostDecrement(1)
			| "(" Expression() ")" #FunctionCall(2)
			| "[" Expression() "]" #ArrayAccess(2))*
}

void AtomicExpression() #void() : {}
{
    Identifier()
    | Number()
    | StringLiteral()
    | CharacterConstant()
    | "(" Expression() ")"
}

void Identifier() #Identifier : {}
{
    <IDENTIFIER>
}

void CharacterConstant() : {}
{
    <CHARACTER_CONST>
}

void Number() : {}
{
    <NUMBER>
}

void StringLiteral() : {}
{
    <STRING_LIT>
}

void Boolean_Not() : {}
{
    <BOOLEAN_NOT>
    {
        System.out.print("! ");
    }
}

void Boolean_And() : {}
{
    <BOOLEAN_AND>
    {
        System.out.print("&& ");
    }
}

void Boolean_Or() : {}
{
    <BOOLEAN_OR>
    {
        System.out.print("|| ");
    }
}

void Bit_Not() : {}
{
    <BIT_NOT>
    {
        System.out.print("~ ");
    }
}

void Bit_And() : {}
{
    <BIT_AND>
    {
        System.out.print("& ");
    }
}

void Bit_Or() : {}
{
    <BIT_OR>
    {
        System.out.print("| ");
    }
}

void Bit_Xor() : {}
{
    <BIT_XOR>
    {
        System.out.print("^ ");
    }
}

void Left_Shift() : {}
{
    <LEFT_SHIFT>
    {
        System.out.print("<< ");
    }
}

void Right_Shift() : {}
{
    <RIGHT_SHIFT>
    {
        System.out.print(">> ");
    }
}

void R_Paren() : {}
{
    <R_PAREN>
    {
        System.out.print(") ");
    }
}

void L_Paren() : {}
{
    <L_PAREN>
    {
        System.out.print("( ");
    }
}

void Plus() : {}
{
    <PLUS>
    {
        System.out.print("+ ");
    }
}

void Plus_Plus() : {}
{
    <PLUS_PLUS>
    {
        System.out.print("++ ");
    }
}

void Minus() : {}
{
    <MINUS>
    {
        System.out.print("- ");
    }
}

void Minus_Minus() : {}
{
    <MINUS_MINUS>
    {
        System.out.print("-- ");
    }
}

void Star(): {}
{
    <STAR>
    {
        System.out.print("* ");
    }
}

void Mod() : {}
{
    <MOD>
    {
        System.out.print("% ");
    }
}

void Divide() : {}
{
    <DIVIDE>
    {
        System.out.print("/ ");
    }
}

void Equals() : {}
{
    <EQUALS>
    {
        System.out.print("= ");
    }
}

void Less_Than() : {}
{
    <LESS_THAN>
    {
        System.out.print("< ");
    }
}

void Greater_Than() : {}
{
    <GREATER_THAN>
    {
        System.out.print("> ");
    }
}

void Equals_Equals() #void : {}
{
    <EQUALS_EQUALS>
    {
        System.out.print("== ");
    }
}

void Not_Equals() : {}
{
    <NOT_EQUALS>
    {
        System.out.print("!= ");
    }
}

void Tokens() : {}
{
    (FunctionDefinition() | Statement() | <COMMENT>)* <EOF>
}
