     ****************************************************************
     ***  pascal2.s
     ***  Generated by Small-C Compiler on 23-Feb-2015 00:05:05
     ****************************************************************

     READ      EQU  001                * Read area
     PUNCH     EQU  101                * Punch area
     PRINT     EQU  201                * Print area
     
     PRCPOS    DCW  000                * char position in print area
     PUCPOS    DCW  000                * char position in punch area
     PUNSIZ    DCW  @080@              * Size of punch area
     PRTSIZ    DCW  @132@              * Size of print area
     EOS       DCW  @'@                * End Of String char
     EOL       DCW  @;@                * End Of Line char

               ORG  87
     X1        DSA  0                  * INDEX REGISTER 1
               ORG  92
     X2        DSA  0                  * INDEX REGISTER 2
               ORG  97
     X3        DSA  0                  * INDEX REGISTER 3
     
     * I need a single digit flag - should I replace this with a DA?
     RF        EQU  340
     
     ****************************************************************  
     * SET THE START POSITION OF CODE
               ORG  1600

     START     NOP  

     * SET THE STACK POINTER
               SBR  X2,400

               MCW  X2,X3
               LCA  LZBAAA,1005
               LCA  LACAAA,1025
               LCA  LBCAAA,1028
               LCA  LCCAAA,1033
               
               B    LXBAAA
               H    
     * FunctionDefinition((15))
     LPAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LQAAAA:null:14)
               LCA  LCDAAA,9+X3
               LCA  LDDAAA,14+X3
               MA   LEDAAA,X2
     * Assignment(start=str)
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LFDAAA,X2
               LCA  15992+X3,0+X2
     * Push(LGDAAA:3)
               MA   LFDAAA,X2
               LCA  LGDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     * if(retree.statement.BlockStatement@3c22d5b5:retree.statement.IfStatement@12fc7ceb)
     * LessThanExpression(value:0)
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LKDAAA,X2
               LCA  15997+X3,0+X2
               B    LLDAAA
     * ConstantExpression(0)
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               B    LLDAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
               MCW  LNDAAA,0+X2
               BL   LODAAA
               B    LPDAAA
     LODAAA    MCW  LDDAAA,0+X2
     LPDAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LIDAAA,5+X2, 
     * BlockStatement(LRAAAA:LQAAAA:0)
     * Assignment(( *(str++) )='-')
     * ConstantExpression(45)
     * Push(LRDAAA:1)
               MA   LSDAAA,X2
               LCA  LRDAAA,0+X2
     * PostIncrement(str)
     * Push(LTDAAA:3)
               MA   LFDAAA,X2
               LCA  LTDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     * Assignment(value=(-value))
     * NegExpression(value)
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LKDAAA,X2
               LCA  15997+X3,0+X2
               ZS   0+X2
               B    LLDAAA
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LQDAAA,X2
     LRAAAA    NOP  
               BCE  LQAAAA,RF,R
               B    LJDAAA
     LIDAAA    NOP  
     * if(retree.statement.BlockStatement@32f02db7:null)
     * EqualExpression(value:0)
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LKDAAA,X2
               LCA  15997+X3,0+X2
               B    LLDAAA
     * ConstantExpression(0)
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               B    LLDAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               BE   LWDAAA
               B    LXDAAA
     LWDAAA    MCW  LDDAAA,0+X2
     LXDAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LVDAAA,5+X2, 
     * BlockStatement(LSAAAA:LQAAAA:0)
     * Assignment((str[0])='0')
     * ConstantExpression(48)
     * Push(LYDAAA:1)
               MA   LSDAAA,X2
               LCA  LYDAAA,0+X2
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LFDAAA,X2
               LCA  15992+X3,0+X2
     * ConstantExpression(0)
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
     * raw index on the stack
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LZDAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     * Assignment((str[1])='\0')
     * ConstantExpression(0)
     * Push(LGEAAA:1)
               MA   LSDAAA,X2
               LCA  LGEAAA,0+X2
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LFDAAA,X2
               LCA  15992+X3,0+X2
     * ConstantExpression(1)
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
     * raw index on the stack
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LZDAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     * VariableExpression(start:6:false)
     * Push(6+X3:3)
               MA   LFDAAA,X2
               LCA  6+X3,0+X2
     * Pop(15984+X3:3)
               LCA  0+X2,15984+X3
               MA   LHDAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LSAAAA
     LSAAAA    NOP  
               BCE  LQAAAA,RF,R
     LVDAAA    NOP  
     LJDAAA    NOP  
     LHEAAA    NOP  
     * LessThanOrEqualExpression(exp:retree.expression.DivideExpression@36496381)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LKDAAA,X2
               LCA  14+X3,0+X2
               B    LLDAAA
     * Divide(value/base)
     * VariableExpression(base:-11:false)
     * Push(15989+X3:5)
               MA   LKDAAA,X2
               LCA  15989+X3,0+X2
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LKDAAA,X2
               LCA  15997+X3,0+X2
               B    LJEAAA
               MCW  0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
               B    LLDAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
               MCW  LDDAAA,0+X2
               BH   LPEAAA
               B    LQEAAA
     LPEAAA    MCW  LNDAAA,0+X2
     LQEAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LIEAAA,5+X2, 
     * Assignment(exp=(exp * base))
     * Multiplication(exp*base)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LKDAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression(base:-11:false)
     * Push(15989+X3:5)
               MA   LKDAAA,X2
               LCA  15989+X3,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * Push(LEDAAA:3)
               MA   LFDAAA,X2
               LCA  LEDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LQDAAA,X2
               B    LHEAAA
     LIEAAA    NOP  
     LREAAA    NOP  
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LKDAAA,X2
               LCA  14+X3,0+X2
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LSEAAA,5+X2, 
     * BlockStatement(LTAAAA:LQAAAA:0)
     * Assignment(( *(str++) )=(digits[retree.expression.DivideExpression@9bee93]))
     * SubScriptEpression(digits:retree.expression.DivideExpression@9bee93)
     * VariableExpression(digits:9:false)
     * Push(9+X3:3)
               MA   LFDAAA,X2
               LCA  9+X3,0+X2
     * Divide(value/exp)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LKDAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LKDAAA,X2
               LCA  15997+X3,0+X2
               B    LJEAAA
               MCW  0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * raw index on the stack
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LZDAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * PostIncrement(str)
     * Push(LTDAAA:3)
               MA   LFDAAA,X2
               LCA  LTDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     * Assignment(value=retree.expression.ModuloExpression@7d4bf534)
     * ModuloExpression(value:exp)
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LKDAAA,X2
               LCA  14+X3,0+X2
     * VariableExpression(value:-3:false)
     * Push(15997+X3:5)
               MA   LKDAAA,X2
               LCA  15997+X3,0+X2
               B    LJEAAA
     * Pop(5)
               MA   LQDAAA,X2
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LQDAAA,X2
     * Assignment(exp=retree.expression.DivideExpression@5cf6930)
     * Divide(exp/base)
     * VariableExpression(base:-11:false)
     * Push(15989+X3:5)
               MA   LKDAAA,X2
               LCA  15989+X3,0+X2
     * VariableExpression(exp:14:false)
     * Push(14+X3:5)
               MA   LKDAAA,X2
               LCA  14+X3,0+X2
               B    LJEAAA
               MCW  0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * Push(LEDAAA:3)
               MA   LFDAAA,X2
               LCA  LEDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LQDAAA,X2
     LTAAAA    NOP  
               BCE  LQAAAA,RF,R
               B    LREAAA
     LSEAAA    NOP  
     * Assignment(( *str )='\0')
     * ConstantExpression(0)
     * Push(LGEAAA:1)
               MA   LSDAAA,X2
               LCA  LGEAAA,0+X2
     * VariableExpression(str:-8:false)
     * Push(15992+X3:3)
               MA   LFDAAA,X2
               LCA  15992+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     * VariableExpression(start:6:false)
     * Push(6+X3:3)
               MA   LFDAAA,X2
               LCA  6+X3,0+X2
     * Pop(15984+X3:3)
               LCA  0+X2,15984+X3
               MA   LHDAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LQAAAA
     LQAAAA    NOP  
               MA   LTEAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((36))
     LKBAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LLBAAA:null:7)
               MA   LUEAAA,X2
     * Assignment(arg=((*char) (( &cformat_str ) + (15997))))
     * Addition(( &cformat_str )+(15997))
     * AddressOfExpression(cformat_str)
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   X3,0+X2
     * ConstantExpression(15997)
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * Push(LGDAAA:3)
               MA   LFDAAA,X2
               LCA  LGDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     LVEAAA    NOP  
     * NotEqualExpression((c = ( *(cformat_str++) )):'\0')
     * Assignment(c=( *(cformat_str++) ))
     * DereferenceExpression((cformat_str++))
     * PostIncrement(cformat_str)
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * Push(LUEAAA:3)
               MA   LFDAAA,X2
               LCA  LUEAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
               LCA  0+X2,0+X1
     * ConstantExpression(0)
     * Push(LGEAAA:1)
               MA   LSDAAA,X2
               LCA  LGEAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               BE   LXEAAA
               B    LYEAAA
     LXEAAA    MCW  LNDAAA,0+X2
     LYEAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LWEAAA,5+X2, 
     * BlockStatement(LMBAAA:LLBAAA:0)
     * if(retree.statement.BlockStatement@64fa8cc6:retree.statement.BlockStatement@7d304ef4)
     * NotEqualExpression(c:'%')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSDAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(37)
     * Push(LDFAAA:1)
               MA   LSDAAA,X2
               LCA  LDFAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               BE   LBFAAA
               B    LCFAAA
     LBFAAA    MCW  LNDAAA,0+X2
     LCFAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LZEAAA,5+X2, 
     * BlockStatement(LNBAAA:LMBAAA:0)
     * FunctionCallExpr((20))
     * Push(5)
               MA   LKDAAA,X2
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSDAAA,X2
               LCA  7+X3,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     LNBAAA    NOP  
               BCE  LMBAAA,RF,R
               B    LAFAAA
     LZEAAA    NOP  
     * BlockStatement(LOBAAA:LMBAAA:0)
     * Assignment(c=( *(cformat_str++) ))
     * DereferenceExpression((cformat_str++))
     * PostIncrement(cformat_str)
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * Push(LUEAAA:3)
               MA   LFDAAA,X2
               LCA  LUEAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     * if(retree.statement.BlockStatement@6e8fb561:retree.statement.IfStatement@1ccd2bfc)
     * EqualExpression(c:'%')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSDAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(37)
     * Push(LDFAAA:1)
               MA   LSDAAA,X2
               LCA  LDFAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               BE   LGFAAA
               B    LHFAAA
     LGFAAA    MCW  LDDAAA,0+X2
     LHFAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LEFAAA,5+X2, 
     * BlockStatement(LPBAAA:LOBAAA:0)
     * FunctionCallExpr((20))
     * Push(5)
               MA   LKDAAA,X2
     * ConstantExpression(37)
     * Push(LDFAAA:1)
               MA   LSDAAA,X2
               LCA  LDFAAA,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     LPBAAA    NOP  
               BCE  LOBAAA,RF,R
               B    LFFAAA
     LEFAAA    NOP  
     * if(retree.statement.BlockStatement@6202bc29:retree.statement.IfStatement@218f5a04)
     * EqualExpression(c:'C')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSDAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(67)
     * Push(LMFAAA:1)
               MA   LSDAAA,X2
               LCA  LMFAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               BE   LKFAAA
               B    LLFAAA
     LKFAAA    MCW  LDDAAA,0+X2
     LLFAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LIFAAA,5+X2, 
     * BlockStatement(LQBAAA:LOBAAA:0)
     * FunctionCallExpr((20))
     * Push(5)
               MA   LKDAAA,X2
     * DereferenceExpression((arg--))
     * PostDecrement(arg)
     * Push(LGDAAA:3)
               MA   LFDAAA,X2
               LCA  LGDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LUDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     LQBAAA    NOP  
               BCE  LOBAAA,RF,R
               B    LJFAAA
     LIFAAA    NOP  
     * if(retree.statement.BlockStatement@4a5ecdd2:retree.statement.IfStatement@161abc23)
     * EqualExpression(c:'S')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSDAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(83)
     * Push(LRFAAA:1)
               MA   LSDAAA,X2
               LCA  LRFAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               BE   LPFAAA
               B    LQFAAA
     LPFAAA    MCW  LDDAAA,0+X2
     LQFAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LNFAAA,5+X2, 
     * BlockStatement(LRBAAA:LOBAAA:0)
     * FunctionCallExpr((26))
     * Push(5)
               MA   LKDAAA,X2
     * DereferenceExpression(((**char) arg))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LFDAAA,X2
               LCA  6+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LABAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(3)
               MA   LHDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     * Assignment(arg=(arg + (15997)))
     * Addition(arg+(15997))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LFDAAA,X2
               LCA  6+X3,0+X2
     * ConstantExpression(15997)
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * Push(LGDAAA:3)
               MA   LFDAAA,X2
               LCA  LGDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     LRBAAA    NOP  
               BCE  LOBAAA,RF,R
               B    LOFAAA
     LNFAAA    NOP  
     * if(retree.statement.BlockStatement@3535a92b:retree.statement.BlockStatement@55f56157)
     * EqualExpression(c:'D')
     * VariableExpression(c:7:false)
     * Push(7+X3:1)
               MA   LSDAAA,X2
               LCA  7+X3,0+X2
     * ConstantExpression(68)
     * Push(LWFAAA:1)
               MA   LSDAAA,X2
               LCA  LWFAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               BE   LUFAAA
               B    LVFAAA
     LUFAAA    MCW  LDDAAA,0+X2
     LVFAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LSFAAA,5+X2, 
     * BlockStatement(LSBAAA:LOBAAA:7)
               MA   LUEAAA,X2
     * FunctionCallExpr((15))
     * Push(3)
               MA   LFDAAA,X2
     * ConstantExpression(10)
     * Push(LXFAAA:5)
               MA   LKDAAA,X2
               LCA  LXFAAA,0+X2
     * ArrayNameExpresssion(a:char [7]:LYFAAA:local)
     * Push(LYFAAA:3)
               MA   LFDAAA,X2
               LCA  LYFAAA,0+X2
               MA   X3,0+X2
     * DereferenceExpression(((*int) arg))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LFDAAA,X2
               LCA  6+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:5)
               MA   LKDAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LPAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     * Pop(3)
               MA   LHDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     * Pop(3)
               MA   LHDAAA,X2
     * FunctionCallExpr((26))
     * Push(5)
               MA   LKDAAA,X2
     * ArrayNameExpresssion(a:char [7]:LYFAAA:local)
     * Push(LYFAAA:3)
               MA   LFDAAA,X2
               LCA  LYFAAA,0+X2
               MA   X3,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LABAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(3)
               MA   LHDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     * Assignment(arg=(arg + (15995)))
     * Addition(arg+(15995))
     * VariableExpression(arg:6:false)
     * Push(6+X3:3)
               MA   LFDAAA,X2
               LCA  6+X3,0+X2
     * ConstantExpression(15995)
     * Push(LQDAAA:3)
               MA   LFDAAA,X2
               LCA  LQDAAA,0+X2
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * Push(LGDAAA:3)
               MA   LFDAAA,X2
               LCA  LGDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     LSBAAA    NOP  
               MA   LZFAAA,X2
               BCE  LOBAAA,RF,R
               B    LTFAAA
     LSFAAA    NOP  
     * BlockStatement(LTBAAA:LOBAAA:0)
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LTBAAA
     LTBAAA    NOP  
               BCE  LOBAAA,RF,R
     LTFAAA    NOP  
     LOFAAA    NOP  
     LJFAAA    NOP  
     LFFAAA    NOP  
     LOBAAA    NOP  
               BCE  LMBAAA,RF,R
     LAFAAA    NOP  
     LMBAAA    NOP  
               BCE  LLBAAA,RF,R
               B    LVEAAA
     LWEAAA    NOP  
     LLBAAA    NOP  
               MA   LZFAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((7))
     LHAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LIAAAA:null:3)
               MA   LFDAAA,X2
     LAGAAA    NOP  
     * NotEqualExpression((( *(dest++) ) = ( *(src++) )):'\0')
     * Assignment(( *(dest++) )=( *(src++) ))
     * DereferenceExpression((src++))
     * PostIncrement(src)
     * Push(LEGAAA:3)
               MA   LFDAAA,X2
               LCA  LEGAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * PostIncrement(dest)
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
               LCA  0+X2,0+X1
     * ConstantExpression(0)
     * Push(LGEAAA:1)
               MA   LSDAAA,X2
               LCA  LGEAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               BE   LCGAAA
               B    LDGAAA
     LCGAAA    MCW  LNDAAA,0+X2
     LDGAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LBGAAA,5+X2, 
               B    LAGAAA
     LBGAAA    NOP  
     LIAAAA    NOP  
               MA   LHDAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((1))
     LBAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LCAAAA:null:3)
               MA   LFDAAA,X2
     * Assignment(seed=retree.expression.ModuloExpression@308a58a5)
     * ModuloExpression(((42 * seed) + 19):100000)
     * ConstantExpression(100000)
     * Push(LFGAAA:5)
               MA   LKDAAA,X2
               LCA  LFGAAA,0+X2
     * Addition((42 * seed)+19)
     * Multiplication(42*seed)
     * ConstantExpression(42)
     * Push(LGGAAA:5)
               MA   LKDAAA,X2
               LCA  LGGAAA,0+X2
     * VariableExpression(seed:1005:true)
     * Push(LHGAAA:5)
               MA   LKDAAA,X2
               LCA  LHGAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * ConstantExpression(19)
     * Push(LIGAAA:5)
               MA   LKDAAA,X2
               LCA  LIGAAA,0+X2
               A    0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
               B    LJEAAA
     * Pop(5)
               MA   LQDAAA,X2
     * Push(LHGAAA:3)
               MA   LFDAAA,X2
               LCA  LHGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:5)
               LCA  0+X2,0+X1
               MA   LQDAAA,X2
     * VariableExpression(seed:1005:true)
     * Push(LHGAAA:5)
               MA   LKDAAA,X2
               LCA  LHGAAA,0+X2
     * Pop(15997+X3:5)
               LCA  0+X2,15997+X3
               MA   LQDAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LCAAAA
     LCAAAA    NOP  
               MA   LHDAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((49))
     LXBAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LYBAAA:null:3)
               MA   LFDAAA,X2
     * FunctionCallExpr((36))
     * Push(5)
               MA   LKDAAA,X2
     * ArrayNameExpresssion("\nDone.\n":char [8]:LJGAAA:static)
     * Push(LJGAAA:3)
               MA   LFDAAA,X2
               LCA  LJGAAA,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LKBAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(3)
               MA   LHDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     LYBAAA    NOP  
               MA   LHDAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((26))
     LABAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LBBAAA:null:3)
               MA   LFDAAA,X2
     LKGAAA    NOP  
     * NotEqualExpression(( *s ):'\0')
     * DereferenceExpression(s)
     * VariableExpression(s:-3:false)
     * Push(15997+X3:3)
               MA   LFDAAA,X2
               LCA  15997+X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * ConstantExpression(0)
     * Push(LGEAAA:1)
               MA   LSDAAA,X2
               LCA  LGEAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               BE   LMGAAA
               B    LNGAAA
     LMGAAA    MCW  LNDAAA,0+X2
     LNGAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LLGAAA,5+X2, 
     * BlockStatement(LCBAAA:LBBAAA:0)
     * FunctionCallExpr((20))
     * Push(5)
               MA   LKDAAA,X2
     * DereferenceExpression((s++))
     * PostIncrement(s)
     * Push(LHDAAA:3)
               MA   LFDAAA,X2
               LCA  LHDAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * Push(X3:3)
               MA   LFDAAA,X2
               LCA  X3,0+X2
               MCW  X2,X3
               B    LUAAAA
     * Pop(X3:3)
               LCA  0+X2,X3
               MA   LHDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(5)
               MA   LQDAAA,X2
     LCBAAA    NOP  
               BCE  LBBAAA,RF,R
               B    LKGAAA
     LLGAAA    NOP  
     LBBAAA    NOP  
               MA   LHDAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((20))
     LUAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LVAAAA:null:3)
               MA   LFDAAA,X2
     * if(retree.statement.BlockStatement@7aa35e0f:retree.statement.BlockStatement@7b7469af)
     * NotEqualExpression(c:'\n')
     * VariableExpression(c:-3:false)
     * Push(15997+X3:1)
               MA   LSDAAA,X2
               LCA  15997+X3,0+X2
     * ConstantExpression(10)
     * Push(LSGAAA:1)
               MA   LSDAAA,X2
               LCA  LSGAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               BE   LQGAAA
               B    LRGAAA
     LQGAAA    MCW  LNDAAA,0+X2
     LRGAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LOGAAA,5+X2, 
     * BlockStatement(LWAAAA:LVAAAA:0)
     * Assignment(( *(__putchar_pos++) )=c)
     * VariableExpression(c:-3:false)
     * Push(15997+X3:1)
               MA   LSDAAA,X2
               LCA  15997+X3,0+X2
     * PostIncrement(__putchar_pos)
     * Push(LTGAAA:3)
               MA   LFDAAA,X2
               LCA  LTGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LSDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     LWAAAA    NOP  
               BCE  LVAAAA,RF,R
               B    LPGAAA
     LOGAAA    NOP  
     * BlockStatement(LXAAAA:LVAAAA:0)
     LUGAAA    NOP  
     * GreaterThanOrEqualExpression(((int) __putchar_last):((int) __putchar_pos))
     * VariableExpression(__putchar_last:1028:true)
     * Push(LWGAAA:3)
               MA   LFDAAA,X2
               LCA  LWGAAA,0+X2
               B    LXGAAA
               B    LLDAAA
     * VariableExpression(__putchar_pos:1025:true)
     * Push(LTGAAA:3)
               MA   LFDAAA,X2
               LCA  LTGAAA,0+X2
               B    LXGAAA
               B    LLDAAA
               C    0+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
               MCW  LDDAAA,0+X2
               BL   LGHAAA
               B    LHHAAA
     LGHAAA    MCW  LNDAAA,0+X2
     LHHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LVGAAA,5+X2, 
     * BlockStatement(LYAAAA:LXAAAA:0)
     * Assignment(( *(__putchar_last--) )=' ')
     * ConstantExpression(32)
     * Push(LIHAAA:1)
               MA   LSDAAA,X2
               LCA  LIHAAA,0+X2
     * PostDecrement(__putchar_last)
     * Push(LWGAAA:3)
               MA   LFDAAA,X2
               LCA  LWGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:3)
               MA   LFDAAA,X2
               LCA  0+X1,0+X2
               MA   LUDAAA,0+X1
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:1)
               LCA  0+X2,0+X1
               MA   LUDAAA,X2
     LYAAAA    NOP  
               BCE  LXAAAA,RF,R
               B    LUGAAA
     LVGAAA    NOP  
     * Assignment(__putchar_last=__putchar_pos)
     * VariableExpression(__putchar_pos:1025:true)
     * Push(LTGAAA:3)
               MA   LFDAAA,X2
               LCA  LTGAAA,0+X2
     * Push(LWGAAA:3)
               MA   LFDAAA,X2
               LCA  LWGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     * Assignment(__putchar_pos=(201))
     * ConstantExpression(201)
     * Push(LACAAA:3)
               MA   LFDAAA,X2
               LCA  LACAAA,0+X2
     * Push(LTGAAA:3)
               MA   LFDAAA,X2
               LCA  LTGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     * Start asm block
               W    
     * End asm block
     LXAAAA    NOP  
               BCE  LVAAAA,RF,R
     LPGAAA    NOP  
     * if(retree.statement.BlockStatement@7110506e:null)
     * EqualExpression(__putchar_pos:(333))
     * VariableExpression(__putchar_pos:1025:true)
     * Push(LTGAAA:3)
               MA   LFDAAA,X2
               LCA  LTGAAA,0+X2
     * ConstantExpression(333)
     * Push(LMHAAA:3)
               MA   LFDAAA,X2
               LCA  LMHAAA,0+X2
               C    0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * Pop(3)
               MA   LHDAAA,X2
     * Push(LNDAAA:5)
               MA   LKDAAA,X2
               LCA  LNDAAA,0+X2
               BE   LKHAAA
               B    LLHAAA
     LKHAAA    MCW  LDDAAA,0+X2
     LLHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LJHAAA,5+X2, 
     * BlockStatement(LZAAAA:LVAAAA:0)
     * Assignment(__putchar_last=__putchar_pos)
     * VariableExpression(__putchar_pos:1025:true)
     * Push(LTGAAA:3)
               MA   LFDAAA,X2
               LCA  LTGAAA,0+X2
     * Push(LWGAAA:3)
               MA   LFDAAA,X2
               LCA  LWGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     * Assignment(__putchar_pos=(201))
     * ConstantExpression(201)
     * Push(LACAAA:3)
               MA   LFDAAA,X2
               LCA  LACAAA,0+X2
     * Push(LTGAAA:3)
               MA   LFDAAA,X2
               LCA  LTGAAA,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Pop(0+X1:3)
               LCA  0+X2,0+X1
               MA   LHDAAA,X2
     * Start asm block
               W    
     * End asm block
     LZAAAA    NOP  
               BCE  LVAAAA,RF,R
     LJHAAA    NOP  
     LVAAAA    NOP  
               MA   LHDAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     * FunctionDefinition((5))
     LFAAAA    SBR  3+X3
               SW   1+X3
               CW   2+X3
               CW   3+X3
     * BlockStatement(LGAAAA:null:8)
               LCA  LNHAAA,8+X3
               MA   LYFAAA,X2
     LOHAAA    NOP  
     * NotEqualExpression((str[(++len)]):'\0')
     * SubScriptEpression(str:(++len))
     * VariableExpression(str:-3:false)
     * Push(15997+X3:3)
               MA   LFDAAA,X2
               LCA  15997+X3,0+X2
     * PreIncrement(len)
     * Push(LYFAAA:3)
               MA   LFDAAA,X2
               LCA  LYFAAA,0+X2
               MA   X3,0+X2
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
               A    LDDAAA,0+X1
     * Push(0+X1:5)
               MA   LKDAAA,X2
               LCA  0+X1,0+X2
     * raw index on the stack
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               M    15995+X2,6+X2
               SW   2+X2
               LCA  6+X2,15995+X2
     * Pop(5)
               MA   LQDAAA,X2
     * STACK TOP IS NOW ARRAY INDEX
               B    LZDAAA
               MA   0+X2,15997+X2
     * Pop(3)
               MA   LHDAAA,X2
     * STACK top is location in array now.
     * Pop(X1:3)
               LCA  0+X2,X1
               MA   LHDAAA,X2
     * Push(0+X1:1)
               MA   LSDAAA,X2
               LCA  0+X1,0+X2
     * ConstantExpression(0)
     * Push(LGEAAA:1)
               MA   LSDAAA,X2
               LCA  LGEAAA,0+X2
               C    0+X2,15999+X2
     * Pop(1)
               MA   LUDAAA,X2
     * Pop(1)
               MA   LUDAAA,X2
     * Push(LDDAAA:5)
               MA   LKDAAA,X2
               LCA  LDDAAA,0+X2
               BE   LQHAAA
               B    LRHAAA
     LQHAAA    MCW  LNDAAA,0+X2
     LRHAAA    NOP  
               MCS  0+X2,0+X2
     * Pop(5)
               MA   LQDAAA,X2
               BCE  LPHAAA,5+X2, 
               B    LOHAAA
     LPHAAA    NOP  
     * VariableExpression(len:8:false)
     * Push(8+X3:5)
               MA   LKDAAA,X2
               LCA  8+X3,0+X2
     * Pop(15994+X3:5)
               LCA  0+X2,15994+X3
               MA   LQDAAA,X2
     * set the return flag, so we know do deallocate our stack
               MCW  @R@,RF
     * and branch
               B    LGAAAA
     LGAAAA    NOP  
               MA   LTDAAA,X2
               MCW  @ @,RF
               LCA  3+X3,X1
               B    0+X1
     LLDAAA    SBR  X1
     * Normalizes the zone bits of a number, leaving either A=0B=0
     * for a positive or A=0B=1 for a negative
     * Do nothing on either no zone bits or only a b zone bit
               BWZ  LMDAAA,0+X2,2
               BWZ  LMDAAA,0+X2,K
     * else clear the zone bits, as it is positive
               MZ   @ @,0+X2
     LMDAAA    B    0+X1
    ****************************************************************  
    ** DIVISION SNIPPET                                           **
    ****************************************************************  
     
     LJEAAA    SBR  LKEAAA+3           * SETUP RETURN ADDRESS
     * POP DIVIDEND
               MCW  0+X2, LLEAAA
               SBR  X2, 15995+X2

     * POP DIVISOR
               MCW  0+X2, LMEAAA
               SBR  X2, 15995+X2


               B    *+17
               
               DCW  @00000@                
               DC   @00000000000@        

               ZA   LLEAAA, *-7         * PUT DIVIDEND INTO WORKING BL
               D    LMEAAA, *-19        * DIVIDE
               MZ   *-22, *-21          * KILL THE ZONE BIT
               MZ   *-29, *-34          * KILL THE ZONE BIT
               MCW  *-41, LNEAAA        * PICK UP ANSWER
               SW   *-44                * SO I CAN PICKUP REMAINDER
               MCW  *-46, LOEAAA        * GET REMAINDER
               CW   *-55                * CLEAR THE WM
               MZ   LNEAAA-1, LNEAAA    * CLEANUP QUOTIENT BITZONE
               MZ   LOEAAA-1, LOEAAA    * CLEANUP REMAINDER BITZONE
               
     * PUSH REMAINDER
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LOEAAA, 0+X2
               
     * PUSH QUOTIENT
               SBR  X2, 5+X2
               SW   15996+X2
               MCW  LNEAAA, 0+X2

     LKEAAA    B    000                 * JUMP BACK
               
     LMEAAA    DCW  00000               * DIVISOR
     LLEAAA    DCW  00000               * DIVIDEND
     LNEAAA    DCW  00000               * QUOTIENT
     LOEAAA    DCW  00000               * REMAINDER
     LZDAAA    SBR  X1
     * Casts a 5-digit number to a 3-digit address
     * make a copy of the top of the stack
               SW   15998+X2
               LCA  0+X2,3+X2
               CW   15998+X2
     * zero out the zone bits of our copy
               MZ   @0@,3+X2
               MZ   @0@,2+X2
               MZ   @0@,1+X2
     * set the low-order digit's zone bits
               C    @04000@,0+X2
               BL   LCEAAA
               C    @08000@,0+X2
               BL   LBEAAA
               C    @12000@,0+X2
               BL   LAEAAA
               S    @12000@,0+X2
               MZ   @A@,3+X2
               B    LCEAAA
     LAEAAA    S    @08000@,0+X2
               MZ   @I@,3+X2
               B    LCEAAA
     LBEAAA    S    @04000@,0+X2
               MZ   @S@,3+X2
     * For some reason the zone bits get set - it still works though.
     LCEAAA    C    @01000@,0+X2
               BL   LFEAAA
               C    @02000@,0+X2
               BL   LEEAAA
               C    @03000@,0+X2
               BL   LDEAAA
               MZ   @A@,1+X2
               B    LFEAAA
     LDEAAA    MZ   @I@,1+X2
               B    LFEAAA
     LEEAAA    MZ   @S@,1+X2
     LFEAAA    LCA  3+X2,15998+X2
               SBR  X2,15998+X2
               B    0+X1
     LXGAAA    SBR  X1
     * Casts a 3-digit address to a 5-digit number
     * Make room on the stack for an int
               MA   @002@,X2
     * make a copy of the top of the stack
               LCA  15998+X2,3+X2
     * Now zero out the top of the stack
               LCA  @00000@,0+X2
     * Now copy back, shifted over 2 digits
               MCW  3+X2,0+X2
     * Now zero out the zone bits on the stack
               MZ   @0@,0+X2
               MZ   @0@,15999+X2
               MZ   @0@,15998+X2
     * check the high-order digit's zone bits
               BWZ  LYGAAA,1+X2,S
               BWZ  LZGAAA,1+X2,K
               BWZ  LAHAAA,1+X2,B
               B    LBHAAA
     LYGAAA    A    @01000@,0+X2
               B    LBHAAA
     LZGAAA    A    @02000@,0+X2
               B    LBHAAA
     LAHAAA    A    @03000@,0+X2
     LBHAAA    BWZ  LCHAAA,3+X2,S
               BWZ  LDHAAA,3+X2,K
               BWZ  LEHAAA,3+X2,B
               B    LFHAAA
     LCHAAA    A    @04000@,0+X2
               B    LFHAAA
     LDHAAA    A    @08000@,0+X2
               B    LFHAAA
     LEHAAA    A    @12000@,0+X2
     LFHAAA    B    0+X1

     * SET THE START POSITION OF DATA
               ORG  1100

     LDCAAA    DCW  @0@
     LECAAA    DCW  @1@
     LFCAAA    DCW  @2@
     LGCAAA    DCW  @3@
     LHCAAA    DCW  @4@
     LICAAA    DCW  @5@
     LJCAAA    DCW  @6@
     LKCAAA    DCW  @7@
     LLCAAA    DCW  @8@
     LMCAAA    DCW  @9@
     LNCAAA    DCW  @A@
     LOCAAA    DCW  @B@
     LPCAAA    DCW  @C@
     LQCAAA    DCW  @D@
     LRCAAA    DCW  @E@
     LSCAAA    DCW  @F@
     LTCAAA    DCW  @'@
     LUCAAA    DCW  @;@
     LVCAAA    DCW  @D@
     LWCAAA    DCW  @O@
     LXCAAA    DCW  @N@
     LYCAAA    DCW  @E@
     LZCAAA    DCW  @.@
     LADAAA    DCW  @;@
     LBDAAA    DCW  @'@

     LIHAAA    DCW  @ @
     LHDAAA    DCW  @I9G@
     LNHAAA    DCW  @0000J@
     LFGAAA    DCW  @100000@
     LZBAAA    DCW  @69105@
     LGGAAA    DCW  @00042@
     LRDAAA    DCW  @-@
     LWFAAA    DCW  @D@
     LUDAAA    DCW  @I9I@
     LGEAAA    DCW  @'@
     LXFAAA    DCW  @00010@
     LDFAAA    DCW  @%@
     LGDAAA    DCW  @006@
     LACAAA    DCW  @201@
     LYFAAA    DCW  @008@
     LYDAAA    DCW  @0@
     LCDAAA    DCW  @'06@
     LCCAAA    DCW  @081@
     LTDAAA    DCW  @I9B@
     LEGAAA    DCW  @I9D@
     LNDAAA    DCW  @00000@
     LRFAAA    DCW  @S@
     LSDAAA    DCW  @001@
     LDDAAA    DCW  @00001@
     LMFAAA    DCW  @C@
     LFDAAA    DCW  @003@
     LTEAAA    DCW  @I8F@
     LKDAAA    DCW  @005@
     LUEAAA    DCW  @007@
     LBCAAA    DCW  @200@
     LEDAAA    DCW  @014@
     LZFAAA    DCW  @I9C@
     LIGAAA    DCW  @00019@
     LQDAAA    DCW  @I9E@
     LMHAAA    DCW  @333@
     LSGAAA    DCW  @;@

     LJGAAA    DCW  "\nDone.\n"  LUCAAA

     LHGAAA    DCW  seed
     LTGAAA    DCW  __putchar_pos
     LWGAAA    DCW  __putchar_last

               END  START
